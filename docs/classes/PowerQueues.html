<!DOCTYPE html><html class="default" lang="en" data-base="../"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>PowerQueues | power-queues API Docs - v2.1.10</title><meta name="description" content="Documentation for power-queues API Docs"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => window.app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><a href="../index.html" class="title">power-queues API Docs - v2.1.10</a><div id="tsd-toolbar-links"></div><button id="tsd-search-trigger" class="tsd-widget" aria-label="Search"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-search"></use></svg></button><dialog id="tsd-search" aria-label="Search"><input role="combobox" id="tsd-search-input" aria-controls="tsd-search-results" aria-autocomplete="list" aria-expanded="true" autocapitalize="off" autocomplete="off" placeholder="Search the docs" maxLength="100"/><ul role="listbox" id="tsd-search-results"></ul><div id="tsd-search-status" aria-live="polite" aria-atomic="true"><div>Preparing search index...</div></div></dialog><a href="#" class="tsd-widget menu" id="tsd-toolbar-menu-trigger" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb" aria-label="Breadcrumb"><li><a href="" aria-current="page">PowerQueues</a></li></ul><h1>Class PowerQueues</h1></div><section class="tsd-panel tsd-hierarchy" data-refl="1"><h4>Hierarchy</h4><ul class="tsd-hierarchy"><li class="tsd-hierarchy-item"><span class="tsd-signature-type">PowerRedis</span><ul class="tsd-hierarchy"><li class="tsd-hierarchy-item"><span class="tsd-hierarchy-target">PowerQueues</span></li></ul></li></ul></section><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L33">PowerQueues.ts:33</a></li></ul></aside><section class="tsd-panel-group tsd-index-group"><section class="tsd-panel tsd-index-panel"><details class="tsd-index-content tsd-accordion" open><summary class="tsd-accordion-summary tsd-index-summary"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h5 class="tsd-index-heading uppercase">Index</h5></summary><div class="tsd-accordion-details"><section class="tsd-index-section"><h3 class="tsd-index-heading">Constructors</h3><div class="tsd-index-list"><a href="#constructor" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Constructor"><use href="../assets/icons.svg#icon-512"></use></svg><span>constructor</span></a>
</div></section><section class="tsd-index-section"><h3 class="tsd-index-heading">Properties</h3><div class="tsd-index-list"><a href="#approvecount" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>approve<wbr/>Count</span></a>
<a href="#buildbatchcount" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>build<wbr/>Batch<wbr/>Count</span></a>
<a href="#buildbatchmaxcount" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>build<wbr/>Batch<wbr/>Max<wbr/>Count</span></a>
<a href="#executesync" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>execute<wbr/>Sync</span></a>
<a href="#group" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>group</span></a>
<a href="#host" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>host</span></a>
<a href="#idemdonetimeout" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>idem<wbr/>Done<wbr/>Timeout</span></a>
<a href="#idemlocktimeout" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>idem<wbr/>Lock<wbr/>Timeout</span></a>
<a href="#logstatus" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>log<wbr/>Status</span></a>
<a href="#logstatustimeout" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>log<wbr/>Status<wbr/>Timeout</span></a>
<a href="#removeonexecuted" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>remove<wbr/>On<wbr/>Executed</span></a>
<a href="#retrycount" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>retry<wbr/>Count</span></a>
<a href="#selectcount" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>select<wbr/>Count</span></a>
<a href="#selectstuckcount" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>select<wbr/>Stuck<wbr/>Count</span></a>
<a href="#selectstuckmaxtimeout" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>select<wbr/>Stuck<wbr/>Max<wbr/>Timeout</span></a>
<a href="#selectstucktimeout" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>select<wbr/>Stuck<wbr/>Timeout</span></a>
<a href="#selecttimeout" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>select<wbr/>Timeout</span></a>
</div></section><section class="tsd-index-section"><h3 class="tsd-index-heading">Methods</h3><div class="tsd-index-list"><a href="#addtasks" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>add<wbr/>Tasks</span></a>
<a href="#beforeexecute" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>before<wbr/>Execute</span></a>
<a href="#consumerloop" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>consumer<wbr/>Loop</span></a>
<a href="#creategroup" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>create<wbr/>Group</span></a>
<a href="#loadscripts" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>load<wbr/>Scripts</span></a>
<a href="#onbatcherror" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Batch<wbr/>Error</span></a>
<a href="#onbatchready" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Batch<wbr/>Ready</span></a>
<a href="#onerror" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Error</span></a>
<a href="#onexecute" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Execute</span></a>
<a href="#onretry" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Retry</span></a>
<a href="#onsuccess" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Success</span></a>
<a href="#runqueue" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>run<wbr/>Queue</span></a>
<a href="#select" class="tsd-index-link"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>select</span></a>
</div></section></div></details></section></section><details class="tsd-panel-group tsd-member-group tsd-accordion" open><summary class="tsd-accordion-summary" data-key="section-Constructors"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h2>Constructors</h2></summary><section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="constructor"><span>constructor</span><a href="#constructor" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="constructorpowerqueues"><span class="tsd-signature-keyword">new</span> <span class="tsd-kind-constructor-signature">PowerQueues</span><span class="tsd-signature-symbol">()</span><span class="tsd-signature-symbol">:</span> <a href="" class="tsd-signature-type tsd-kind-class">PowerQueues</a><a href="#constructorpowerqueues" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><h4 class="tsd-returns-title">Returns <a href="" class="tsd-signature-type tsd-kind-class">PowerQueues</a></h4><aside class="tsd-sources"><p>Inherited from PowerRedis.constructor</p></aside></div></li></ul></section></section></details><details class="tsd-panel-group tsd-member-group tsd-accordion" open><summary class="tsd-accordion-summary" data-key="section-Properties"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h2>Properties</h2></summary><section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="approvecount"><code class="tsd-tag">Readonly</code><span>approve<wbr/>Count</span><a href="#approvecount" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">approveCount</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 2000</span></div><div class="tsd-comment tsd-typography"><p>Target maximum number of task IDs to acknowledge (approve) in a single ACK batch.</p>
<p>This value is used by approve to control how many Redis Stream entries
are acknowledged at once using the Lua script <code>Approve</code>.</p>
<p>Why batching ACKs exists:</p>
<ul>
<li>Acknowledging each message one-by-one is slow (many Redis round-trips).</li>
<li>Acknowledging too many in one call can create huge argv payloads and latency spikes.</li>
</ul>
<p>So approve clamps this value to a safe range:</p>
<pre><code class="ts"><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-4">approveCount</span><span class="hl-1"> = </span><span class="hl-5">Math</span><span class="hl-1">.</span><span class="hl-0">max</span><span class="hl-1">(</span><span class="hl-7">500</span><span class="hl-1">, </span><span class="hl-5">Math</span><span class="hl-1">.</span><span class="hl-0">min</span><span class="hl-1">(</span><span class="hl-7">4000</span><span class="hl-1">, </span><span class="hl-3">this</span><span class="hl-1">.</span><span class="hl-5">approveCount</span><span class="hl-1">));</span>
</code><button type="button">Copy</button></pre>

<p>Meaning:</p>
<ul>
<li>minimum effective batch size is <strong>500</strong></li>
<li>maximum effective batch size is <strong>4000</strong></li>
<li>values outside that range will be forced into it</li>
</ul>
<hr>
<h2 id="what-approve-means-here" class="tsd-anchor-link">What &quot;approve&quot; means here<a href="#what-approve-means-here" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Approving a task means:</p>
<ul>
<li>removing it from the consumer group's Pending Entries List (PEL),</li>
<li>and optionally deleting it from the stream entirely if <a href="#removeonexecuted" class="tsd-kind-property">removeOnExecuted</a> is true
(depends on what the <code>Approve</code> Lua script does).</li>
</ul>
<p>This is typically equivalent to Redis <code>XACK</code> (and sometimes <code>XDEL</code>),
but implemented as a single Lua script for performance and atomic behavior.</p>
<hr>
<h2 id="why-it-matters" class="tsd-anchor-link">Why it matters<a href="#why-it-matters" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Larger values reduce Redis round-trips under high throughput,
but increase per-call payload size and can increase latency spikes.</li>
<li>Smaller values create more Redis calls, which can limit throughput.</li>
</ul>
<hr>
<h2 id="tuning-recommendations" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Keep it in the <code>500</code>–<code>4000</code> range (anything else is clamped anyway).</li>
<li>If you have very high throughput and stable Redis, <code>2000</code>–<code>4000</code> can be efficient.</li>
<li>If you see latency spikes during ACK, reduce it closer to <code>500</code>–<code>1000</code>.</li>
</ul>
<p>Default in this class: <code>2000</code>.</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L747">PowerQueues.ts:747</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="buildbatchcount"><code class="tsd-tag">Readonly</code><span>build<wbr/>Batch<wbr/>Count</span><a href="#buildbatchcount" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">buildBatchCount</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 800</span></div><div class="tsd-comment tsd-typography"><p>Maximum number of tasks to include in a single <strong>producer batch</strong> when enqueuing tasks.</p>
<p>This value is used by buildBatches to split the input array passed to <a href="#addtasks" class="tsd-kind-method">addTasks</a>
into smaller chunks.</p>
<p>Why batching exists:</p>
<ul>
<li><a href="#addtasks" class="tsd-kind-method">addTasks</a> inserts tasks using the Lua script <code>XAddBulk</code>.</li>
<li>A single Redis call has practical limits (argument count / payload size).</li>
<li>Splitting into batches protects you from oversized requests and improves stability.</li>
</ul>
<p><code>buildBatchCount</code> is the <strong>first</strong> batching limit:</p>
<ul>
<li>If the current batch already contains <code>buildBatchCount</code> tasks, a new batch is started.</li>
</ul>
<p>The final batch size is also limited by <a href="#buildbatchmaxcount" class="tsd-kind-property">buildBatchMaxCount</a> (argv/token limit),
so the real batch size can be smaller than <code>buildBatchCount</code> if tasks are large.</p>
<hr>
<h2 id="tuning-recommendations-1" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>For small payloads and high throughput, values like <code>500</code>–<code>2000</code> can be good.</li>
<li>For large payloads, reduce this number to avoid big Lua argv arrays and timeouts.</li>
<li>Always consider Redis network latency and your average payload size.</li>
</ul>
<p>Default in this class: <code>800</code>.</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L374">PowerQueues.ts:374</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="buildbatchmaxcount"><code class="tsd-tag">Readonly</code><span>build<wbr/>Batch<wbr/>Max<wbr/>Count</span><a href="#buildbatchmaxcount" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">buildBatchMaxCount</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 10000</span></div><div class="tsd-comment tsd-typography"><p>Maximum allowed size of a producer batch expressed as an approximate <strong>Redis argv token limit</strong>.</p>
<p>This value is used by buildBatches as a safety cap to prevent creating a batch
that would produce an excessively large argument list for the <code>XAddBulk</code> Lua script call.</p>
<p>In Redis, a Lua script is invoked like:
<code>EVALSHA &lt;sha&gt; &lt;numKeys&gt; &lt;keys...&gt; &lt;args...&gt;</code></p>
<p>For bulk <code>XADD</code>, the number of <code>&lt;args...&gt;</code> grows quickly with:</p>
<ul>
<li>how many tasks you enqueue in one batch,</li>
<li>and how many fields each task contains (payload, createdAt, job, idemKey, attempt, etc.).</li>
</ul>
<p>This setting helps prevent:</p>
<ul>
<li>oversized requests,</li>
<li>long Lua execution time,</li>
<li>hitting Redis/proxy limits,</li>
<li>and increased memory pressure.</li>
</ul>
<hr>
<h2 id="how-it-is-calculated-in-your-code" class="tsd-anchor-link">How it is calculated in your code<a href="#how-it-is-calculated-in-your-code" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>buildBatches estimates the &quot;argument size&quot; using <code>keysLength(task)</code>:</p>
<ul>
<li><code>keysLength(task)</code> returns: <code>2 + Object.keys(task).length * 2</code>
(an approximation of how many argv tokens will be needed for that task)</li>
</ul>
<p>During batch building:</p>
<ul>
<li><code>realKeysLength</code> accumulates <code>reqKeysLength</code> for each task</li>
<li>If adding the next task would exceed <code>buildBatchMaxCount</code>,
the current batch is closed and a new batch is started.</li>
</ul>
<p>So <code>buildBatchMaxCount</code> is the <strong>second</strong> batching limit (in addition to <a href="#buildbatchcount" class="tsd-kind-property">buildBatchCount</a>).</p>
<hr>
<h2 id="why-the-name-contains-count" class="tsd-anchor-link">Why the name contains &quot;Count&quot;<a href="#why-the-name-contains-count" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>It does <strong>not</strong> mean &quot;max tasks&quot;.
It means &quot;max argv tokens&quot; (approximate count of script arguments).
This is important because:</p>
<ul>
<li>800 small tasks might be fine,</li>
<li>but 800 tasks with large metadata or many fields might create a huge argv list.</li>
</ul>
<hr>
<h2 id="tuning-recommendations-2" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>If you see Redis errors related to argument size, timeouts, or slow scripts,
reduce this value (e.g. <code>5000</code>–<code>8000</code>).</li>
<li>If tasks are small and you want fewer Redis round-trips, you can increase it,
but test carefully (bigger calls can increase latency spikes).</li>
</ul>
<p>Default in this class: <code>10000</code>.</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L429">PowerQueues.ts:429</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="executesync"><code class="tsd-tag">Readonly</code><span>execute<wbr/>Sync</span><a href="#executesync" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">executeSync</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol"> = false</span></div><div class="tsd-comment tsd-typography"><p>Controls whether tasks in a batch are executed <strong>sequentially</strong> or <strong>concurrently</strong>.</p>
<p>This flag is used inside execute:</p>
<ul>
<li><code>executeSync = false</code> (default): tasks are executed concurrently using <code>Promise.all</code>.</li>
<li><code>executeSync = true</code>: tasks are executed one by one (await each task before starting next).</li>
</ul>
<hr>
<h2 id="why-this-setting-exists" class="tsd-anchor-link">Why this setting exists<a href="#why-this-setting-exists" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Concurrent execution can drastically increase throughput, but it can also:</p>
<ul>
<li>overload external services (API rate limits)</li>
<li>overload your database</li>
<li>increase memory usage</li>
<li>increase lock contention if many tasks share the same idemKey</li>
</ul>
<p>Sequential execution is slower, but it is simpler and can be safer when:</p>
<ul>
<li>your task handler is not concurrency-safe</li>
<li>you must preserve ordering</li>
<li>you must avoid bursts to downstream systems</li>
</ul>
<hr>
<h2 id="behavior-in-this-implementation" class="tsd-anchor-link">Behavior in this implementation<a href="#behavior-in-this-implementation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>In execute:</p>
<ul>
<li>When <code>executeSync</code> is false, the code collects async functions in <code>promises</code>
and runs them all with <code>Promise.all(...)</code>.</li>
<li>When <code>executeSync</code> is true, it awaits each executeProcess directly in the loop.</li>
</ul>
<p>This setting does <strong>not</strong> limit concurrency to a specific number (like 10 workers).
It is either:</p>
<ul>
<li>fully parallel (one promise per task in the selected batch),</li>
<li>or fully sequential.</li>
</ul>
<p>If you need a fixed concurrency limit, you would implement a small pool/queue in execute.</p>
<hr>
<h2 id="tuning-recommendations-3" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-3" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Keep <code>false</code> for most high-throughput use cases where your downstream systems can handle concurrency.</li>
<li>Set <code>true</code> if you see:
<ul>
<li>frequent rate-limit errors,</li>
<li>contention spikes,</li>
<li>or you need strict ordering guarantees.</li>
</ul>
</li>
</ul>
<p>Default in this class: <code>false</code> (concurrent execution).</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L518">PowerQueues.ts:518</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="group"><code class="tsd-tag">Readonly</code><span>group</span><a href="#group" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">group</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;gr1&#39;</span></div><div class="tsd-comment tsd-typography"><p>Name of the Redis Streams <strong>consumer group</strong> used by this queue worker.</p>
<p>In Redis Streams, a consumer group allows multiple consumers (workers)
to coordinate message processing without duplicating work.</p>
<p>All workers that:</p>
<ul>
<li>use the same <code>queueName</code></li>
<li>and the same <code>group</code></li>
</ul>
<p>will share the same consumer group state (Pending Entries List, last delivered ID, etc.).</p>
<hr>
<h2 id="what-is-a-consumer-group" class="tsd-anchor-link">What is a consumer group?<a href="#what-is-a-consumer-group" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>A consumer group:</p>
<ul>
<li>Tracks which messages were delivered</li>
<li>Tracks which messages are still pending (not acknowledged)</li>
<li>Distributes new messages across consumers in the group</li>
</ul>
<p>Example Redis command used internally:
<code>XGROUP CREATE &lt;queueName&gt; &lt;group&gt; &lt;from&gt;</code></p>
<hr>
<h2 id="how-this-affects-scaling" class="tsd-anchor-link">How this affects scaling<a href="#how-this-affects-scaling" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<h3 id="horizontal-scaling-multiple-workers" class="tsd-anchor-link">Horizontal scaling (multiple workers)<a href="#horizontal-scaling-multiple-workers" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3>
<p>If you want multiple worker instances to cooperate on the same queue:</p>
<ul>
<li>Use the <strong>same <code>group</code> name</strong></li>
<li>Ensure each worker has a unique consumer name (handled by <code>host + pid</code>)</li>
</ul>
<p>This way:</p>
<ul>
<li>Redis distributes new messages across workers</li>
<li>Stuck/pending messages can be reclaimed by other workers</li>
</ul>
<h3 id="independent-processing" class="tsd-anchor-link">Independent processing<a href="#independent-processing" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3>
<p>If you want different services to process the same stream independently:</p>
<ul>
<li>Use <strong>different <code>group</code> names</strong></li>
</ul>
<p>Each group will:</p>
<ul>
<li>Maintain its own delivery position</li>
<li>Have its own Pending Entries List</li>
<li>Process the same messages separately</li>
</ul>
<hr>
<h2 id="example-scenarios" class="tsd-anchor-link">Example scenarios<a href="#example-scenarios" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Single logical worker group:</p>
<pre><code class="ts"><span class="hl-5">group</span><span class="hl-1"> = </span><span class="hl-2">&quot;alerts-workers&quot;</span>
</code><button type="button">Copy</button></pre>

<p>Two independent consumers of the same stream:</p>
<pre><code class="ts"><span class="hl-11">// Service A</span><br/><span class="hl-5">group</span><span class="hl-1"> = </span><span class="hl-2">&quot;alerts-email&quot;</span><br/><br/><span class="hl-11">// Service B</span><br/><span class="hl-5">group</span><span class="hl-1"> = </span><span class="hl-2">&quot;alerts-telegram&quot;</span>
</code><button type="button">Copy</button></pre>

<hr>
<h2 id="best-practices" class="tsd-anchor-link">Best practices<a href="#best-practices" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Choose a stable and descriptive name (e.g. <code>&quot;monitoring-workers-v1&quot;</code>).</li>
<li>Do not randomly change this value in production — doing so creates a new group
and may cause old messages to be reprocessed depending on <code>from</code>.</li>
<li>If you deploy breaking changes in message format, consider versioning the group name.</li>
</ul>
<p>Default in this class: <code>&quot;gr1&quot;</code> (simple placeholder).</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L143">PowerQueues.ts:143</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="host"><code class="tsd-tag">Readonly</code><span>host</span><a href="#host" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">host</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;host&#39;</span></div><div class="tsd-comment tsd-typography"><p>Logical host identifier used to build a unique Redis Streams <strong>consumer name</strong>.</p>
<p>This value is combined with the current process id to form consumer:
<code>&quot;&lt;host&gt;:&lt;pid&gt;&quot;</code>.</p>
<p>Why it matters:</p>
<ul>
<li>In Redis Streams consumer groups, each worker instance must have a distinct consumer name.</li>
<li>Using <code>host + pid</code> makes collisions very unlikely even if you run multiple workers
on the same machine or inside multiple containers.</li>
</ul>
<p>Example:</p>
<ul>
<li><code>host = &quot;monitoring-worker-1&quot;</code></li>
<li><code>process.pid = 12345</code></li>
<li><code>consumer()</code> becomes <code>&quot;monitoring-worker-1:12345&quot;</code></li>
</ul>
<p>Practical recommendations:</p>
<ul>
<li>Set this to something stable and human-readable in production:
hostname, container name, service instance id, etc.</li>
<li>If you run multiple pods/containers, include the pod/container identifier in <code>host</code>.</li>
</ul>
<p>Default in this class is <code>&quot;host&quot;</code> (placeholder).</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L66">PowerQueues.ts:66</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="idemdonetimeout"><code class="tsd-tag">Readonly</code><span>idem<wbr/>Done<wbr/>Timeout</span><a href="#idemdonetimeout" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">idemDoneTimeout</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 60000</span></div><div class="tsd-comment tsd-typography"><p>Idempotency &quot;done&quot; TTL (time-to-live) in <strong>milliseconds</strong>.</p>
<p>After a task with a given <code>idemKey</code> is executed successfully, the queue marks it as completed
by writing a <code>doneKey</code> in Redis. This prevents duplicate execution if the same logical task
is delivered again (for example, due to retries, consumer rebalancing, or producer duplication).</p>
<p><code>idemDoneTimeout</code> controls how long that &quot;already done&quot; marker remains in Redis.</p>
<hr>
<h2 id="where-it-is-used" class="tsd-anchor-link">Where it is used<a href="#where-it-is-used" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>It is passed to the Lua script IdempotencyDone:</p>
<ul>
<li>idempotencyDone calls:
<code>runScript('IdempotencyDone', [doneKey, lockKey, startKey], [ String(idemDoneTimeout), token ])</code></li>
</ul>
<p>Typically the script:</p>
<ul>
<li>sets <code>doneKey</code> with TTL = <code>idemDoneTimeout</code></li>
<li>deletes or releases <code>lockKey</code> and <code>startKey</code></li>
</ul>
<hr>
<h2 id="why-it-matters-1" class="tsd-anchor-link">Why it matters<a href="#why-it-matters-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Higher values increase protection against duplicates (stronger idempotency window),
but keep more keys in Redis for longer (more memory usage).</li>
<li>Lower values reduce memory usage, but allow duplicates to execute again sooner
if the same <code>idemKey</code> is reintroduced after the TTL expires.</li>
</ul>
<p>You can think of it as:
<strong>&quot;How long do we remember that this idemKey was already processed?&quot;</strong></p>
<hr>
<h2 id="tuning-recommendations-4" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-4" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Pick this based on how long duplicates might realistically occur in your system:</p>
<ul>
<li>If duplicates can happen within seconds/minutes (common), 30–300 seconds is fine.</li>
<li>If duplicates can happen much later (rare), increase it — but monitor Redis memory.</li>
<li>If <code>idemKey</code> is unique per message (UUID), you can keep it relatively small,
because duplicates are mostly immediate.</li>
</ul>
<p>Default in this class: <code>60_000</code> ms (60 seconds).</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L612">PowerQueues.ts:612</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="idemlocktimeout"><code class="tsd-tag">Readonly</code><span>idem<wbr/>Lock<wbr/>Timeout</span><a href="#idemlocktimeout" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">idemLockTimeout</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 180000</span></div><div class="tsd-comment tsd-typography"><p>Idempotency lock TTL (time-to-live) in <strong>milliseconds</strong>.</p>
<p>This value controls how long a worker keeps the idempotency &quot;lock&quot; alive in Redis
while it is processing a task with a given <code>idemKey</code>.</p>
<p>Idempotency in this queue is implemented with Redis keys:</p>
<ul>
<li><code>doneKey</code>  — marks that this <code>idemKey</code> was already completed recently</li>
<li><code>lockKey</code>  — a mutex-like lock to prevent two workers executing the same <code>idemKey</code> at once</li>
<li><code>startKey</code> — a marker that execution has started (used for waiting/contended behavior)</li>
</ul>
<p><code>idemLockTimeout</code> is used as the TTL for <code>lockKey</code> and <code>startKey</code>.</p>
<hr>
<h2 id="where-it-is-used-1" class="tsd-anchor-link">Where it is used<a href="#where-it-is-used-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>idempotencyAllow passes it to the Lua gate script (<code>IdempotencyAllow</code>)</li>
<li>idempotencyStart sets it when acquiring the lock (<code>IdempotencyStart</code>)</li>
<li>heartbeat periodically refreshes TTL via sendHeartbeat</li>
</ul>
<p>In code:</p>
<ul>
<li><code>IdempotencyAllow(..., [ String(this.idemLockTimeout), token ])</code></li>
<li><code>IdempotencyStart(..., [ token, String(this.idemLockTimeout) ])</code></li>
<li><code>sendHeartbeat()</code> calls <code>PEXPIRE(lockKey, idemLockTimeout)</code> and <code>PEXPIRE(startKey, idemLockTimeout)</code></li>
</ul>
<hr>
<h2 id="why-it-matters-2" class="tsd-anchor-link">Why it matters<a href="#why-it-matters-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>
<p>Too small:</p>
<ul>
<li>long-running tasks may outlive the lock TTL,</li>
<li>another worker can acquire the same <code>idemKey</code> and run duplicate work.</li>
</ul>
</li>
<li>
<p>Too large:</p>
<ul>
<li>if a worker crashes, the lock stays in Redis for longer,</li>
<li>other workers will treat the task as &quot;contended&quot; and wait longer before retrying.</li>
</ul>
</li>
</ul>
<p>Heartbeat reduces the risk for long tasks by extending the TTL while the worker is alive.</p>
<hr>
<h2 id="tuning-recommendations-5" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-5" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Choose a value slightly larger than your typical <strong>maximum task execution time</strong>.</li>
<li>If tasks can take ~30 seconds, use something like 60–120 seconds.</li>
<li>If tasks can take several minutes, use several minutes (and keep heartbeat enabled).</li>
<li>For very fast tasks, you can lower it, but keep some buffer for GC pauses / network hiccups.</li>
</ul>
<p>Default in this class: <code>180_000</code> ms (3 minutes).</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L568">PowerQueues.ts:568</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="logstatus"><code class="tsd-tag">Readonly</code><span>log<wbr/>Status</span><a href="#logstatus" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">logStatus</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol"> = false</span></div><div class="tsd-comment tsd-typography"><p>Enable or disable lightweight queue status tracking in Redis.</p>
<p>When <code>logStatus</code> is <code>true</code>, the queue writes simple counters into Redis to track
how many tasks were:</p>
<ul>
<li>processed successfully (<code>ok</code>)</li>
<li>failed (<code>err</code>)</li>
<li>and &quot;ready&quot; (a total-like counter updated on both success and error paths)</li>
</ul>
<p>Counters are stored per queue and per job:
Key prefix format:
<code>&quot;&lt;queueName&gt;:&lt;job&gt;:&quot;</code></p>
<p>Keys that may be written:</p>
<ul>
<li><code>&quot;&lt;queueName&gt;:&lt;job&gt;:ok&quot;</code></li>
<li><code>&quot;&lt;queueName&gt;:&lt;job&gt;:err&quot;</code></li>
<li><code>&quot;&lt;queueName&gt;:&lt;job&gt;:ready&quot;</code></li>
</ul>
<p>These counters are incremented in:</p>
<ul>
<li>success (on success → <code>ok</code> and <code>ready</code>)</li>
<li>error and batchError (on final failure / DLQ path → <code>err</code> and <code>ready</code>)</li>
</ul>
<p>All status keys are set with TTL = <a href="#logstatustimeout" class="tsd-kind-property">logStatusTimeout</a>, so they expire automatically.</p>
<hr>
<h2 id="why-it-matters-3" class="tsd-anchor-link">Why it matters<a href="#why-it-matters-3" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Turning this on gives you a very cheap way to monitor queue progress without external tooling:</p>
<ul>
<li>&quot;How many tasks have completed for job X?&quot;</li>
<li>&quot;How many errors happened for job X?&quot;</li>
</ul>
<p>Turning it off removes this Redis write overhead, which can matter at very high throughput.</p>
<hr>
<h2 id="tuning-recommendations-6" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-6" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Enable it in production if you want basic visibility and the extra Redis writes are acceptable.</li>
<li>Disable it if you already have strong observability (Prometheus, logs, tracing)
or if you need absolute maximum throughput.</li>
</ul>
<p>Default in this class: <code>false</code>.</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L656">PowerQueues.ts:656</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="logstatustimeout"><code class="tsd-tag">Readonly</code><span>log<wbr/>Status<wbr/>Timeout</span><a href="#logstatustimeout" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">logStatusTimeout</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 1800000</span></div><div class="tsd-comment tsd-typography"><p>TTL (time-to-live) in <strong>milliseconds</strong> for status/metrics keys written when <a href="#logstatus" class="tsd-kind-property">logStatus</a> is enabled.</p>
<p>When <code>logStatus = true</code>, the queue increments counters in Redis such as:</p>
<ul>
<li><code>&quot;&lt;queueName&gt;:&lt;job&gt;:ok&quot;</code></li>
<li><code>&quot;&lt;queueName&gt;:&lt;job&gt;:err&quot;</code></li>
<li><code>&quot;&lt;queueName&gt;:&lt;job&gt;:ready&quot;</code>
and also (when <a href="#addtasks" class="tsd-kind-method">addTasks</a> is called with <code>opts.status = true</code>):</li>
<li><code>&quot;&lt;queueName&gt;:&lt;job&gt;:total&quot;</code></li>
</ul>
<p>This setting controls how long those keys remain in Redis before expiring automatically.</p>
<hr>
<h2 id="why-it-matters-4" class="tsd-anchor-link">Why it matters<a href="#why-it-matters-4" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Higher TTL keeps history longer (useful for debugging and monitoring),
but increases Redis memory usage (keys stick around longer).</li>
<li>Lower TTL reduces memory usage, but you may lose visibility sooner
(status keys disappear quickly).</li>
</ul>
<p>You can think of it as:
<strong>&quot;How long should job counters remain available after the job finishes?&quot;</strong></p>
<hr>
<h2 id="where-it-is-used-2" class="tsd-anchor-link">Where it is used<a href="#where-it-is-used-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>success: increments <code>ok</code> and <code>ready</code> with TTL = <code>logStatusTimeout</code></li>
<li>error: increments <code>err</code> and <code>ready</code> with TTL = <code>logStatusTimeout</code></li>
<li>batchError: may set/increment counters with TTL = <code>logStatusTimeout</code></li>
<li><a href="#addtasks" class="tsd-kind-method">addTasks</a>: sets <code>&lt;queueName&gt;:&lt;job&gt;:total</code> and applies TTL = <code>logStatusTimeout</code></li>
</ul>
<hr>
<h2 id="tuning-recommendations-7" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-7" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>If you want to see recent jobs for a few hours, use something like <code>1h</code>–<code>12h</code>.</li>
<li>If you want to keep counters for 1–7 days, increase it, but monitor Redis memory.</li>
<li>If you have external monitoring, a shorter TTL is usually enough.</li>
</ul>
<p>Default in this class: <code>1_800_000</code> ms (30 minutes).</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L698">PowerQueues.ts:698</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="removeonexecuted"><code class="tsd-tag">Readonly</code><span>remove<wbr/>On<wbr/>Executed</span><a href="#removeonexecuted" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">removeOnExecuted</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol"> = true</span></div><div class="tsd-comment tsd-typography"><p>Controls whether successfully acknowledged tasks should also be <strong>removed from the Redis Stream</strong>.</p>
<p>This flag is passed into the Approve Lua script by approve:</p>
<ul>
<li><code>'1'</code> when <code>removeOnExecuted</code> is <code>true</code></li>
<li><code>'0'</code> when <code>removeOnExecuted</code> is <code>false</code></li>
</ul>
<p>Conceptually, there are two common ways to use Redis Streams as a queue:</p>
<ol>
<li>
<p><strong>Keep stream history</strong> (removeOnExecuted = false)</p>
<ul>
<li>Messages are acknowledged (removed from the consumer group's pending list),
but remain in the stream.</li>
<li>Pros:
<ul>
<li>You keep an audit/history of what was produced.</li>
<li>You can create new consumer groups later and replay old messages (if desired).</li>
</ul>
</li>
<li>Cons:
<ul>
<li>Stream grows forever unless you trim it (<code>MAXLEN</code>, <code>MINID</code>, etc.).</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Delete after processing</strong> (removeOnExecuted = true)</p>
<ul>
<li>Messages are acknowledged and then deleted from the stream (usually via <code>XDEL</code>).</li>
<li>Pros:
<ul>
<li>Stream does not accumulate processed messages (acts more like a classic queue).</li>
<li>Lower Redis memory usage without requiring trimming.</li>
</ul>
</li>
<li>Cons:
<ul>
<li>You lose history (cannot replay the exact same message later).</li>
<li>Debugging/auditing requires external logs/metrics.</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="how-it-is-used" class="tsd-anchor-link">How it is used<a href="#how-it-is-used" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>In approve:</p>
<pre><code class="ts"><span class="hl-3">this</span><span class="hl-1">.</span><span class="hl-0">runScript</span><span class="hl-1">(</span><span class="hl-2">&#39;Approve&#39;</span><span class="hl-1">, [</span><span class="hl-5">queueName</span><span class="hl-1">], [</span><br/><span class="hl-1">  </span><span class="hl-3">this</span><span class="hl-1">.</span><span class="hl-5">group</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-3">this</span><span class="hl-1">.</span><span class="hl-5">removeOnExecuted</span><span class="hl-1"> ? </span><span class="hl-2">&#39;1&#39;</span><span class="hl-1"> : </span><span class="hl-2">&#39;0&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  ...</span><span class="hl-5">ids</span><br/><span class="hl-1">], </span><span class="hl-5">Approve</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The exact behavior depends on the <code>Approve</code> Lua script implementation, but typically:</p>
<ul>
<li>always performs <code>XACK</code> for the given ids</li>
<li>optionally performs <code>XDEL</code> (or similar cleanup) when the flag is <code>1</code></li>
</ul>
<hr>
<h2 id="tuning-recommendations-8" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-8" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Set to <code>true</code> if you want queue-like behavior and do not need message history.</li>
<li>Set to <code>false</code> if you need replay/audit and you also configure trimming
(<code>maxlen</code>, <code>minid*</code>, etc.) to avoid unbounded growth.</li>
</ul>
<p>Default in this class: <code>true</code>.</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L801">PowerQueues.ts:801</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="retrycount"><code class="tsd-tag">Readonly</code><span>retry<wbr/>Count</span><a href="#retrycount" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">retryCount</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 1</span></div><div class="tsd-comment tsd-typography"><p>Maximum number of attempts allowed for a task (including the first attempt).</p>
<p>This value controls the retry behavior when <a href="#onexecute" class="tsd-kind-method">onExecute</a> throws an error.</p>
<p>How it is interpreted in code:</p>
<ul>
<li><code>attempt</code> starts from <code>0</code> for the first run.</li>
<li>A retry is scheduled while:
<code>attempt &lt; (retryCount - 1)</code></li>
</ul>
<p>So:</p>
<ul>
<li><code>retryCount = 1</code>  → no retries (only attempt <code>0</code>)</li>
<li><code>retryCount = 2</code>  → one retry (attempts <code>0</code> and <code>1</code>)</li>
<li><code>retryCount = 3</code>  → two retries (attempts <code>0</code>, <code>1</code>, <code>2</code>)</li>
</ul>
<p>This logic is implemented in error and also in batchError.</p>
<hr>
<h2 id="what-happens-on-failure" class="tsd-anchor-link">What happens on failure<a href="#what-happens-on-failure" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>When a task fails:</p>
<ul>
<li>If more attempts remain:
<ul>
<li><a href="#onretry" class="tsd-kind-method">onRetry</a> is called</li>
<li>the task is re-enqueued into the same queue with <code>attempt + 1</code></li>
</ul>
</li>
<li>If attempts are exhausted:
<ul>
<li>if <a href="#logstatus" class="tsd-kind-property">logStatus</a> is enabled, the task is sent to the DLQ queue (<code>&lt;queueName&gt;:dlq</code>)</li>
<li><a href="#onerror" class="tsd-kind-method">onError</a> is called in both cases (after retry/DLQ decision)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="tuning-recommendations-9" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-9" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>For non-critical tasks where duplicates are acceptable: <code>2</code>–<code>5</code> retries may be fine.</li>
<li>For critical tasks: combine retries with idempotency and good error classification.</li>
<li>Avoid very high values unless you also implement backoff/delay, otherwise you can
create retry storms under outages.</li>
</ul>
<p>Default in this class: <code>1</code> (no retries).</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L469">PowerQueues.ts:469</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="selectcount"><code class="tsd-tag">Readonly</code><span>select<wbr/>Count</span><a href="#selectcount" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">selectCount</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 200</span></div><div class="tsd-comment tsd-typography"><p>Maximum number of <strong>new</strong> messages to read from the stream in one <code>XREADGROUP</code> call.</p>
<p>This value is used by selectF, which reads fresh (never-delivered) messages using:
<code>XREADGROUP ... COUNT &lt;selectCount&gt; STREAMS &lt;queueName&gt; &gt;</code></p>
<p>So <code>selectCount</code> is the <strong>batch size</strong> for normal consumption of new tasks.</p>
<hr>
<h2 id="why-it-matters-5" class="tsd-anchor-link">Why it matters<a href="#why-it-matters-5" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Higher values improve throughput (fewer Redis round-trips),
but can increase memory usage and make each loop iteration heavier.</li>
<li>Lower values reduce per-iteration work, but may limit throughput when the queue is busy.</li>
</ul>
<p>This setting should be tuned together with:</p>
<ul>
<li><a href="#selecttimeout" class="tsd-kind-property">selectTimeout</a> (how long we block waiting for new messages)</li>
<li><a href="#approvecount" class="tsd-kind-property">approveCount</a> (how many ACKs we do per request)</li>
<li>your average task execution time and worker concurrency</li>
</ul>
<hr>
<h2 id="tuning-recommendations-10" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-10" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>If tasks are fast and you want high throughput, values like <code>200</code>–<code>2000</code> can be good.</li>
<li>If tasks are heavy (slow / expensive), keep it smaller (e.g. <code>20</code>–<code>200</code>)
to avoid very long batches and large retry storms.</li>
</ul>
<p>Default in this class: <code>200</code>.</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L297">PowerQueues.ts:297</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="selectstuckcount"><code class="tsd-tag">Readonly</code><span>select<wbr/>Stuck<wbr/>Count</span><a href="#selectstuckcount" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">selectStuckCount</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 200</span></div><div class="tsd-comment tsd-typography"><p>Maximum number of &quot;stuck&quot; (pending) messages to fetch in a single stuck-selection pass.</p>
<p>This value is used by selectS, which calls the Lua script SelectStuck.
That script is responsible for finding messages that were delivered to some consumer
but were not acknowledged within a reasonable time (for example, because the worker
crashed or lost connectivity).</p>
<p>In other words, this controls the <strong>batch size</strong> for recovering pending work.</p>
<hr>
<h2 id="how-it-is-used-1" class="tsd-anchor-link">How it is used<a href="#how-it-is-used-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Internally we call:
<code>runScript('SelectStuck', [queueName], [ group, consumer, selectStuckTimeout, selectStuckCount, selectStuckMaxTimeout ])</code></p>
<p>So <code>selectStuckCount</code> is passed to Redis as the &quot;COUNT&quot; / limit parameter for stuck selection.</p>
<hr>
<h2 id="why-it-matters-6" class="tsd-anchor-link">Why it matters<a href="#why-it-matters-6" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Higher values recover stuck work faster after outages,
but increase the amount of work processed in one loop iteration
(more memory + longer batch execution time).</li>
<li>Lower values reduce per-iteration load, but recovery may take longer
if there are many pending messages.</li>
</ul>
<hr>
<h2 id="tuning-recommendations-11" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-11" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>For lightweight tasks (fast processing), values like <code>200</code>–<code>2000</code> can be reasonable.</li>
<li>For heavy tasks (slow processing), keep it smaller (e.g. <code>50</code>–<code>200</code>)
to avoid long batches and large retry storms.</li>
<li>Make sure it is balanced with:
<ul>
<li><a href="#selectcount" class="tsd-kind-property">selectCount</a> (new-message batch size),</li>
<li><a href="#approvecount" class="tsd-kind-property">approveCount</a> (ACK batch size),</li>
<li>and your worker throughput.</li>
</ul>
</li>
</ul>
<p>Default in this class: <code>200</code>.</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L185">PowerQueues.ts:185</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="selectstuckmaxtimeout"><code class="tsd-tag">Readonly</code><span>select<wbr/>Stuck<wbr/>Max<wbr/>Timeout</span><a href="#selectstuckmaxtimeout" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">selectStuckMaxTimeout</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 80</span></div><div class="tsd-comment tsd-typography"><p>Upper bound (in seconds) for how long a pending message is allowed to stay &quot;stuck&quot;
before it becomes eligible for more aggressive recovery by the stuck-selection logic.</p>
<p>This value is passed into SelectStuck via selectS.
While <a href="#selectstucktimeout" class="tsd-kind-property">selectStuckTimeout</a> defines the <strong>minimum</strong> idle time (in ms) for a message
to be considered stuck, <code>selectStuckMaxTimeout</code> acts as an additional <strong>cap</strong> / safety limit
(in seconds) that the Lua script can use to decide how far back it should look or how
aggressively it should reclaim very old pending entries.</p>
<p>In simpler words:</p>
<ul>
<li><code>selectStuckTimeout</code> = &quot;don’t touch pending entries until they are idle for at least X ms&quot;</li>
<li><code>selectStuckMaxTimeout</code> = &quot;treat entries older than Y seconds as definitely abandoned&quot;</li>
</ul>
<hr>
<h2 id="how-it-is-used-2" class="tsd-anchor-link">How it is used<a href="#how-it-is-used-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>selectS calls:
<code>runScript('SelectStuck', [queueName], [ group, consumer, selectStuckTimeout, selectStuckCount, selectStuckMaxTimeout ])</code></p>
<p>The exact meaning depends on the Lua script implementation, but commonly it is used to:</p>
<ul>
<li>avoid reclaiming tasks that are only slightly delayed,</li>
<li>and focus on tasks that are clearly abandoned (too old).</li>
</ul>
<hr>
<h2 id="why-it-matters-7" class="tsd-anchor-link">Why it matters<a href="#why-it-matters-7" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Helps avoid &quot;thrashing&quot; (workers repeatedly stealing tasks from each other too early).</li>
<li>Makes recovery deterministic for very old pending entries after outages.</li>
</ul>
<hr>
<h2 id="tuning-recommendations-12" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-12" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Set it to a bit higher than your expected &quot;long task&quot; duration.</li>
<li>If tasks should never take more than ~30 seconds, values like <code>60</code>–<code>120</code> seconds are fine.</li>
<li>If tasks can take several minutes, increase this value accordingly.</li>
</ul>
<p>Default in this class: <code>80</code> seconds.</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L266">PowerQueues.ts:266</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="selectstucktimeout"><code class="tsd-tag">Readonly</code><span>select<wbr/>Stuck<wbr/>Timeout</span><a href="#selectstucktimeout" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">selectStuckTimeout</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 60000</span></div><div class="tsd-comment tsd-typography"><p>Time threshold (in milliseconds) that defines when a pending message is considered &quot;stuck&quot;.</p>
<p>This value is used by selectS (stuck selection) via the Lua script SelectStuck.
Conceptually, a message becomes &quot;stuck&quot; when it was delivered to some consumer,
but was not acknowledged for a long enough time (for example, the worker crashed
after receiving it).</p>
<p><code>selectStuckTimeout</code> tells the stuck-selection script:
<strong>&quot;Only reclaim messages that have been pending for at least this long.&quot;</strong></p>
<hr>
<h2 id="how-it-is-used-3" class="tsd-anchor-link">How it is used<a href="#how-it-is-used-3" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>selectS calls:
<code>runScript('SelectStuck', [queueName], [ group, consumer, selectStuckTimeout, selectStuckCount, selectStuckMaxTimeout ])</code></p>
<p>The script typically compares the idle time of pending entries (PEL) against this threshold.</p>
<hr>
<h2 id="why-it-matters-8" class="tsd-anchor-link">Why it matters<a href="#why-it-matters-8" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Too small → you may reclaim tasks that are still being processed by a slow worker,
increasing duplicate work and contention.</li>
<li>Too large → recovery after a crash is slower (tasks sit pending longer before being reclaimed).</li>
</ul>
<p>This setting should reflect the typical maximum execution time of your tasks plus some buffer.</p>
<hr>
<h2 id="tuning-recommendations-13" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-13" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>If most tasks finish within ~2–5 seconds, a value like <code>30_000</code>–<code>60_000</code> ms is safe.</li>
<li>If tasks can run for minutes, increase this accordingly (or rely more on heartbeat/idempotency).</li>
<li>Consider how it interacts with <a href="#idemlocktimeout" class="tsd-kind-property">idemLockTimeout</a> and heartbeat:
even if a task is reclaimed, idempotency may prevent double execution.</li>
</ul>
<p>Default in this class: <code>60_000</code> ms (60 seconds).</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L225">PowerQueues.ts:225</a></li></ul></aside></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="selecttimeout"><code class="tsd-tag">Readonly</code><span>select<wbr/>Timeout</span><a href="#selecttimeout" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><div class="tsd-signature"><span class="tsd-kind-property">selectTimeout</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = 3000</span></div><div class="tsd-comment tsd-typography"><p>How long (in milliseconds) the worker should <strong>block-wait</strong> for new messages
when reading the queue via <code>XREADGROUP</code>.</p>
<p>This value is used by selectF in the Redis command:
<code>XREADGROUP ... BLOCK &lt;selectTimeout&gt; COUNT &lt;selectCount&gt; STREAMS &lt;queueName&gt; &gt;</code></p>
<p>Meaning:</p>
<ul>
<li>If there are new messages, Redis returns immediately.</li>
<li>If there are no new messages, Redis keeps the connection open and waits up to this
amount of time before returning <code>null</code> / empty response.</li>
</ul>
<hr>
<h2 id="why-it-matters-9" class="tsd-anchor-link">Why it matters<a href="#why-it-matters-9" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>This setting is a trade-off between:</p>
<ul>
<li><strong>low latency</strong> (react quickly when messages appear),</li>
<li>and <strong>low CPU / low Redis load</strong> (avoid tight polling loops).</li>
</ul>
<p>With blocking reads, the worker is mostly idle when the queue is empty.</p>
<hr>
<h2 id="behavior-in-this-implementation-1" class="tsd-anchor-link">Behavior in this implementation<a href="#behavior-in-this-implementation-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>In selectF we call:
<code>BLOCK Math.max(2, this.selectTimeout | 0)</code></p>
<p>So:</p>
<ul>
<li>the value is forced to an integer (<code>| 0</code>)</li>
<li>and has a minimum of <code>2</code> ms (never truly zero)</li>
</ul>
<p>Default: <code>3000</code> ms (3 seconds).</p>
<p>After <code>selectF</code> returns empty, <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a> additionally waits ~300ms
before the next iteration, which further reduces idle spinning.</p>
<hr>
<h2 id="tuning-recommendations-14" class="tsd-anchor-link">Tuning recommendations<a href="#tuning-recommendations-14" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Typical good defaults are <code>1000</code>–<code>5000</code> ms.</li>
<li>Lower values (e.g. <code>50</code>–<code>500</code> ms) can reduce &quot;wake-up&quot; latency slightly,
but increase Redis calls when the queue is empty.</li>
<li>Higher values (e.g. <code>10_000</code>+ ms) reduce Redis traffic even more, but can make
shutdown slightly less responsive (because the worker may be blocked in Redis longer).</li>
</ul>
<p>Default in this class: <code>3000</code> ms.</p>
</div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L346">PowerQueues.ts:346</a></li></ul></aside></section></section></details><details class="tsd-panel-group tsd-member-group tsd-accordion" open><summary class="tsd-accordion-summary" data-key="section-Methods"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h2>Methods</h2></summary><section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="addtasks"><span>add<wbr/>Tasks</span><a href="#addtasks" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="addtasks-1"><span class="tsd-kind-call-signature">addTasks</span><span class="tsd-signature-symbol">(</span><br/>    <span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span><br/>    <span class="tsd-kind-parameter">data</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">,</span><br/>    <span class="tsd-kind-parameter">opts</span><span class="tsd-signature-symbol">?:</span> <a href="../types/AddTasksOptions.html" class="tsd-signature-type tsd-kind-type-alias">AddTasksOptions</a><span class="tsd-signature-symbol">,</span><br/><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">&gt;</span><a href="#addtasks-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Add (enqueue) multiple tasks into a queue (Redis Stream) in an efficient, batched way.</p>
<p>This is the <strong>producer</strong> method of the queue:
you provide an array of task payload objects, and the method appends them to the Redis Stream.</p>
<p>Internally it uses the Lua script <code>XAddBulk</code> to insert many entries with one round-trip per batch,
which is significantly faster than calling <code>XADD</code> for each task individually.</p>
<hr>
<h2 id="what-is-written-into-redis" class="tsd-anchor-link">What is written into Redis?<a href="#what-is-written-into-redis" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Each task becomes a Redis Stream entry with fields like:</p>
<ul>
<li><code>payload</code>   — JSON string (task payload)</li>
<li><code>createdAt</code> — timestamp (ms)</li>
<li><code>job</code>       — job identifier (string)</li>
<li><code>idemKey</code>   — idempotency key (string)</li>
<li><code>attempt</code>   — retry attempt number (integer)</li>
</ul>
<p>These fields are later read by <a href="#select" class="tsd-kind-method">select</a> / selectP and converted back into:
<code>[ id, payloadObject, createdAt, job, idemKey, attempt ]</code>.</p>
<hr>
<h2 id="parameters" class="tsd-anchor-link">Parameters<a href="#parameters" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key (queue name) to append tasks to.
Example: <code>&quot;alerts&quot;</code>, <code>&quot;emails&quot;</code>.</p>
</div></li><li><span><span class="tsd-kind-parameter">data</span>: <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">[]</span></span><div class="tsd-comment tsd-typography"><p>Array of payload objects (tasks) to enqueue.
Each item is expected to be a plain object that will be JSON-stringified and stored in the stream.</p>
<p>Important:</p>
<ul>
<li>The method does <strong>not</strong> validate your payload shape.</li>
<li>Payload objects should be JSON-serializable.</li>
</ul>
</div></li><li><span><span class="tsd-kind-parameter">opts</span>: <a href="../types/AddTasksOptions.html" class="tsd-signature-type tsd-kind-type-alias">AddTasksOptions</a><span class="tsd-signature-symbol"> = {}</span></span><div class="tsd-comment tsd-typography"><p>Additional enqueue options that affect metadata and trimming behavior.</p>
<p>Common options:</p>
<ul>
<li><code>job</code>: Job name for this batch. If not provided, a random UUID is generated.</li>
<li><code>attempt</code>: Retry attempt number to store (default <code>0</code>).</li>
<li><code>createdAt</code>: Timestamp (ms) to store (default <code>Date.now()</code> per task).</li>
<li><code>idemKey</code>: Default idempotency key if tasks don’t include their own <code>idemKey</code>.</li>
<li><code>maxlen</code> / <code>approx</code> / <code>exact</code>: Stream trimming options (like <code>XADD MAXLEN</code>).</li>
<li><code>trimLimit</code>, <code>minidWindowMs</code>, <code>minidExact</code>: additional trimming/window controls used by the script.</li>
<li><code>nomkstream</code>: if true, do not auto-create stream (depends on script behavior).</li>
<li><code>status</code>: if true, write <code>&lt;queueName&gt;:&lt;job&gt;:total</code> with the number of tasks (useful for monitoring).</li>
</ul>
<hr>
<h2 id="how-batching-works" class="tsd-anchor-link">How batching works<a href="#how-batching-works" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Writing thousands of tasks in one Lua call can exceed practical Redis argument limits.
So this method:</p>
<ol>
<li>
<p>Splits <code>data</code> into smaller batches via buildBatches
using two limits:</p>
<ul>
<li><code>this.buildBatchCount</code> (max tasks per batch)</li>
<li><code>this.buildBatchMaxCount</code> (max argv tokens for Redis call)</li>
</ul>
</li>
<li>
<p>Converts each batch into a flat argv array using payloadBatch</p>
</li>
<li>
<p>Executes the Lua script <code>XAddBulk</code> for each batch:
<code>runScript('XAddBulk', [queueName], argv)</code></p>
</li>
<li>
<p>Collects all created stream IDs in the same order as input <code>data</code></p>
</li>
</ol>
<p>The batches are executed concurrently via a small worker pool (one runner per batch),
which improves throughput when Redis latency is non-trivial.</p>
<hr>
<h2 id="return-value" class="tsd-anchor-link">Return value<a href="#return-value" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">&gt;</span></h4><p>A promise that resolves to an array of Redis Stream entry IDs.
The returned array has the <strong>same length and order</strong> as the input <code>data</code>.</p>
<p>Example returned IDs:
<code>[&quot;1700000000000-0&quot;, &quot;1700000000001-0&quot;, ...]</code></p>
<hr>
<h2 id="errors-and-validation" class="tsd-anchor-link">Errors and validation<a href="#errors-and-validation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>This method throws early for obvious misuse:</p>
<ul>
<li>if <code>data</code> is empty → <code>&quot;Tasks is not filled.&quot;</code></li>
<li>if <code>queueName</code> is empty → <code>&quot;Queue name is required.&quot;</code></li>
</ul>
<p>Errors from Redis / Lua execution will also be thrown (e.g. connectivity, script errors).</p>
<hr>
<h2 id="example" class="tsd-anchor-link">Example<a href="#example" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<pre><code class="ts"><span class="hl-6">await</span><span class="hl-1"> </span><span class="hl-5">q</span><span class="hl-1">.</span><span class="hl-0">loadScripts</span><span class="hl-1">(</span><span class="hl-3">false</span><span class="hl-1">); </span><span class="hl-11">// enough for producer mode</span><br/><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-4">ids</span><span class="hl-1"> = </span><span class="hl-6">await</span><span class="hl-1"> </span><span class="hl-5">q</span><span class="hl-1">.</span><span class="hl-0">addTasks</span><span class="hl-1">(</span><span class="hl-2">&#39;alerts&#39;</span><span class="hl-1">, [</span><br/><span class="hl-1">  { </span><span class="hl-5">telegramChatId:</span><span class="hl-1"> </span><span class="hl-7">123</span><span class="hl-1">, </span><span class="hl-5">text:</span><span class="hl-1"> </span><span class="hl-2">&#39;Hello&#39;</span><span class="hl-1"> },</span><br/><span class="hl-1">  { </span><span class="hl-5">telegramChatId:</span><span class="hl-1"> </span><span class="hl-7">456</span><span class="hl-1">, </span><span class="hl-5">text:</span><span class="hl-1"> </span><span class="hl-2">&#39;World&#39;</span><span class="hl-1"> },</span><br/><span class="hl-1">], {</span><br/><span class="hl-1">  </span><span class="hl-5">job:</span><span class="hl-1"> </span><span class="hl-2">&#39;notify-users&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">status:</span><span class="hl-1"> </span><span class="hl-3">true</span><span class="hl-1">,</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-5">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-5">ids</span><span class="hl-1">); </span><span class="hl-11">// [&quot;...&quot;, &quot;...&quot;]</span>
</code><button type="button">Copy</button></pre>

<aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L1863">PowerQueues.ts:1863</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="beforeexecute"><span>before<wbr/>Execute</span><a href="#beforeexecute" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="beforeexecute-1"><span class="tsd-kind-call-signature">beforeExecute</span><span class="tsd-signature-symbol">(</span><br/>    <span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span><br/>    <span class="tsd-kind-parameter">tasks</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-symbol">[</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">]</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">,</span><br/><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-symbol">[</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">]</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">&gt;</span><a href="#beforeexecute-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Hook that runs <strong>right before</strong> the batch is executed.</p>
<p>By default this method does nothing and simply returns the incoming tasks unchanged.
You can override it in a subclass to implement batch-level preprocessing such as:</p>
<ul>
<li>filtering out tasks you don't want to execute</li>
<li>enriching payloads (adding computed fields, defaults, normalized values)</li>
<li>reordering tasks (priorities, grouping)</li>
<li>splitting or merging tasks (advanced use)</li>
<li>lightweight validation (reject obviously invalid payloads early)</li>
</ul>
<p>This hook is called by <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a> as part of the pipeline:</p>
<p><code>select() -&gt; beforeExecute() -&gt; execute() -&gt; approve()</code></p>
<hr>
<h2 id="parameters-1" class="tsd-anchor-link">Parameters<a href="#parameters-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key (queue name) that the tasks were read from.
Useful if you run multiple queues with one worker implementation.</p>
</div></li><li><span><span class="tsd-kind-parameter">tasks</span>: <span class="tsd-signature-symbol">[</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">]</span><span class="tsd-signature-symbol">[]</span></span><div class="tsd-comment tsd-typography"><p>Raw parsed tasks selected from Redis. Each task is a tuple:
<code>[ id, payload, createdAt, job, idemKey, attempt ]</code></p>
<p>Where:</p>
<ul>
<li><code>id</code> (string) — Redis stream entry id</li>
<li><code>payload</code> (any) — parsed payload object (JSON) or raw string</li>
<li><code>createdAt</code> (number) — timestamp from the message fields</li>
<li><code>job</code> (string) — job name/id</li>
<li><code>idemKey</code> (string) — idempotency key</li>
<li><code>attempt</code> (number) — retry attempt counter</li>
</ul>
<hr>
<h2 id="return-value-1" class="tsd-anchor-link">Return value<a href="#return-value-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-symbol">[</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">]</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">&gt;</span></h4><p>A promise that resolves to the batch of tasks that should be executed next.
You may return:</p>
<ul>
<li>the same array (no changes),</li>
<li>a filtered array (skip tasks),</li>
<li>or a modified array (changed payloads, reordered tasks, etc.).</li>
</ul>
<p>Returning an empty array means &quot;execute nothing&quot; for this iteration.</p>
<hr>
<h2 id="important-notes-for-overrides" class="tsd-anchor-link">Important notes for overrides<a href="#important-notes-for-overrides" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Keep this method <strong>fast</strong>: it runs for every batch.</li>
<li>Avoid heavy I/O here (DB calls, network calls). Prefer doing that in <a href="#onexecute" class="tsd-kind-method">onExecute</a>
so failures/retries are tracked per task.</li>
<li>If you throw here, the whole batch is treated as failed and will go through
batchError logic.</li>
</ul>
<hr>
<h2 id="example-override-filter-invalid-payloads" class="tsd-anchor-link">Example override: filter invalid payloads<a href="#example-override-filter-invalid-payloads" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<pre><code class="ts"><span class="hl-5">override</span><span class="hl-1"> </span><span class="hl-5">async</span><span class="hl-1"> </span><span class="hl-0">beforeExecute</span><span class="hl-1">(</span><span class="hl-5">queueName</span><span class="hl-1">: </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">tasks</span><span class="hl-1">: </span><span class="hl-5">Array</span><span class="hl-1">&lt;[</span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">any</span><span class="hl-1">, </span><span class="hl-5">number</span><span class="hl-1">, </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">number</span><span class="hl-1">]&gt;) {</span><br/><span class="hl-1">  </span><span class="hl-6">return</span><span class="hl-1"> </span><span class="hl-5">tasks</span><span class="hl-1">.</span><span class="hl-0">filter</span><span class="hl-1">(([</span><span class="hl-5">id</span><span class="hl-1">, </span><span class="hl-5">payload</span><span class="hl-1">]) </span><span class="hl-3">=&gt;</span><span class="hl-1"> </span><span class="hl-5">payload</span><span class="hl-1"> &amp;&amp; </span><span class="hl-3">typeof</span><span class="hl-1"> </span><span class="hl-5">payload</span><span class="hl-1">.</span><span class="hl-5">telegramChatId</span><span class="hl-1"> === </span><span class="hl-2">&#39;number&#39;</span><span class="hl-1">);</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<h2 id="example-override-add-defaults" class="tsd-anchor-link">Example override: add defaults<a href="#example-override-add-defaults" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<pre><code class="ts"><span class="hl-5">override</span><span class="hl-1"> </span><span class="hl-5">async</span><span class="hl-1"> </span><span class="hl-0">beforeExecute</span><span class="hl-1">(</span><span class="hl-5">queueName</span><span class="hl-1">: </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">tasks</span><span class="hl-1">: </span><span class="hl-5">Array</span><span class="hl-1">&lt;[</span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">any</span><span class="hl-1">, </span><span class="hl-5">number</span><span class="hl-1">, </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">number</span><span class="hl-1">]&gt;) {</span><br/><span class="hl-1">  </span><span class="hl-6">return</span><span class="hl-1"> </span><span class="hl-5">tasks</span><span class="hl-1">.</span><span class="hl-0">map</span><span class="hl-1">(([</span><span class="hl-5">id</span><span class="hl-1">, </span><span class="hl-5">payload</span><span class="hl-1">, </span><span class="hl-5">createdAt</span><span class="hl-1">, </span><span class="hl-5">job</span><span class="hl-1">, </span><span class="hl-5">idemKey</span><span class="hl-1">, </span><span class="hl-5">attempt</span><span class="hl-1">]) </span><span class="hl-3">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-4">p</span><span class="hl-1"> = </span><span class="hl-3">typeof</span><span class="hl-1"> </span><span class="hl-5">payload</span><span class="hl-1"> === </span><span class="hl-2">&#39;object&#39;</span><span class="hl-1"> &amp;&amp; </span><span class="hl-5">payload</span><span class="hl-1"> ? </span><span class="hl-5">payload</span><span class="hl-1"> : { </span><span class="hl-5">value:</span><span class="hl-1"> </span><span class="hl-5">payload</span><span class="hl-1"> };</span><br/><span class="hl-1">    </span><span class="hl-6">if</span><span class="hl-1"> (!(</span><span class="hl-2">&#39;priority&#39;</span><span class="hl-1"> </span><span class="hl-3">in</span><span class="hl-1"> </span><span class="hl-5">p</span><span class="hl-1">)) </span><span class="hl-5">p</span><span class="hl-1">.</span><span class="hl-5">priority</span><span class="hl-1"> = </span><span class="hl-2">&#39;normal&#39;</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-6">return</span><span class="hl-1"> [</span><span class="hl-5">id</span><span class="hl-1">, </span><span class="hl-5">p</span><span class="hl-1">, </span><span class="hl-5">createdAt</span><span class="hl-1">, </span><span class="hl-5">job</span><span class="hl-1">, </span><span class="hl-5">idemKey</span><span class="hl-1">, </span><span class="hl-5">attempt</span><span class="hl-1">] </span><span class="hl-6">as</span><span class="hl-1"> </span><span class="hl-3">const</span><span class="hl-1">;</span><br/><span class="hl-1">  });</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L2071">PowerQueues.ts:2071</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="consumerloop"><span>consumer<wbr/>Loop</span><a href="#consumerloop" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="consumerloop-1"><span class="tsd-kind-call-signature">consumerLoop</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-kind-parameter">from</span><span class="tsd-signature-symbol">?:</span> <span class="tsd-signature-type">&quot;$&quot;</span> <span class="tsd-signature-symbol">|</span> <span class="tsd-signature-type">&quot;0-0&quot;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span><a href="#consumerloop-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Main worker loop that continuously consumes tasks from a Redis Stream and processes them.</p>
<p>This method is designed to run <strong>forever</strong> in normal operation and stops only when
the queue is aborted via abort (i.e. <code>this.abort.abort()</code> is called).</p>
<p>It follows this high-level pipeline:</p>
<ol>
<li><strong>Read</strong> tasks from Redis (first try &quot;stuck&quot; / pending tasks, then new tasks)</li>
<li>If nothing is available → <strong>sleep a bit</strong> and retry</li>
<li><strong>Preprocess</strong> tasks with <a href="#beforeexecute" class="tsd-kind-method">beforeExecute</a> (hook)</li>
<li><strong>Execute</strong> tasks with execute which calls <a href="#onexecute" class="tsd-kind-method">onExecute</a> (hook) per task</li>
<li><strong>Acknowledge</strong> processed tasks via approve (removes them from PEL / stream depending on config)</li>
<li>On any batch error → perform retry/DLQ logic via batchError, then try to acknowledge
the original messages to avoid infinite re-delivery, then continue looping.</li>
</ol>
<hr>
<h2 id="why-a-loop-is-needed" class="tsd-anchor-link">Why a loop is needed<a href="#why-a-loop-is-needed" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Redis Streams do not &quot;push&quot; messages to consumers by default. Workers need to poll (or block-read)
for new entries. We use a loop with blocking reads and small waits to balance:</p>
<ul>
<li>low latency (handle messages quickly),</li>
<li>and low CPU usage (avoid tight spin loops).</li>
</ul>
<hr>
<h2 id="parameters-2" class="tsd-anchor-link">Parameters<a href="#parameters-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key (queue) to consume.</p>
</div></li><li><span><span class="tsd-kind-parameter">from</span>: <span class="tsd-signature-type">&quot;$&quot;</span> <span class="tsd-signature-symbol">|</span> <span class="tsd-signature-type">&quot;0-0&quot;</span><span class="tsd-signature-symbol"> = &#39;0-0&#39;</span></span><div class="tsd-comment tsd-typography"><p>Group creation start point (passed only for recovery when group is missing).
This value is used only if Redis replies with <code>NOGROUP</code> and we need to call <a href="#creategroup" class="tsd-kind-method">createGroup</a>.
See <a href="#creategroup" class="tsd-kind-method">createGroup</a> for details about <code>&quot;$&quot;</code> vs <code>&quot;0-0&quot;</code>.</p>
<p>Default: <code>&quot;0-0&quot;</code>.</p>
<hr>
<h2 id="detailed-behavior" class="tsd-anchor-link">Detailed behavior<a href="#detailed-behavior" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<h3 id="stop-condition" class="tsd-anchor-link">Stop condition<a href="#stop-condition" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3>
<p>The loop checks <code>this.abort.signal.aborted</code>. Once it becomes <code>true</code>,
the loop exits and the promise resolves.</p>
<h3 id="reading-tasks-select" class="tsd-anchor-link">Reading tasks: <a href="#select" class="tsd-kind-method">select</a><a href="#reading-tasks-select" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3>
<p><code>select()</code> tries two strategies:</p>
<ul>
<li>selectS: a Lua-based fetch of <strong>stuck/pending</strong> messages (unacked for too long)</li>
<li>selectF: a normal <code>XREADGROUP ... STREAMS &lt;queueName&gt; &gt;</code> fetch of <strong>new</strong> messages</li>
</ul>
<p>The result is normalized by selectP into tuples:
<code>[ id, payload, createdAt, job, idemKey, attempt ]</code></p>
<h3 id="when-no-tasks-were-read" class="tsd-anchor-link">When no tasks were read<a href="#when-no-tasks-were-read" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3>
<p>If the queue is empty (or nothing is currently available), we wait ~300ms and retry.
This prevents CPU spinning when idle.</p>
<h3 id="execution-and-acknowledgment" class="tsd-anchor-link">Execution and acknowledgment<a href="#execution-and-acknowledgment" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3>
<p>The main processing call:</p>
<p><code>approve(queueName, await execute(queueName, await beforeExecute(queueName, tasks)))</code></p>
<ul>
<li><a href="#beforeexecute" class="tsd-kind-method">beforeExecute</a> is a hook to filter, reorder, enrich, or validate the batch.</li>
<li>execute runs tasks and returns only those that were actually processed successfully.</li>
<li>approve acknowledges those successful tasks (and optionally removes them from the stream).</li>
</ul>
<h3 id="error-handling-batch-level" class="tsd-anchor-link">Error handling (batch-level)<a href="#error-handling-batch-level" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3>
<p>If anything in the processing pipeline throws:</p>
<ul>
<li>batchError is called to:
<ul>
<li>group failed tasks by <code>(attempt, createdAt, job)</code> (see implementation)</li>
<li>re-enqueue tasks if retries are allowed</li>
<li>or move them to DLQ when retries are exhausted (if <code>logStatus</code> is enabled)</li>
<li>call <a href="#onbatcherror" class="tsd-kind-method">onBatchError</a> hook</li>
</ul>
</li>
</ul>
<p>After that, the code <em>tries</em> to acknowledge the original messages anyway using approve.
This is important because otherwise the same broken batch could get re-delivered forever
as pending/stuck messages.</p>
<p>Finally it waits ~300ms and continues the loop.</p>
<hr>
<h2 id="notes-best-practices" class="tsd-anchor-link">Notes &amp; best practices<a href="#notes-best-practices" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>This method intentionally <strong>swallows</strong> read errors and keeps running. In a worker system,
intermittent Redis/network hiccups are expected.</li>
<li>If you want crash-on-fail behavior, implement it inside <a href="#onbatcherror" class="tsd-kind-method">onBatchError</a> or override
this method and rethrow.</li>
<li>For graceful shutdown, call <code>this.abort.abort()</code> and optionally wait for <code>consumerLoop</code>
to resolve.</li>
</ul>
</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4><p>A promise that resolves when the loop stops (when aborted).</p>
<aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L1079">PowerQueues.ts:1079</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="creategroup"><span>create<wbr/>Group</span><a href="#creategroup" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="creategroup-1"><span class="tsd-kind-call-signature">createGroup</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-kind-parameter">from</span><span class="tsd-signature-symbol">?:</span> <span class="tsd-signature-type">&quot;$&quot;</span> <span class="tsd-signature-symbol">|</span> <span class="tsd-signature-type">&quot;0-0&quot;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span><a href="#creategroup-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Ensure that a Redis Stream <strong>consumer group</strong> exists for the given queue (stream).</p>
<p>In Redis Streams, a consumer group must be created <strong>once</strong> before any worker can read
messages using <code>XREADGROUP</code>.</p>
<p>This method is <strong>safe to call on every startup</strong>:</p>
<ul>
<li>If the group already exists, Redis throws a <code>BUSYGROUP</code> error → we ignore it.</li>
<li>If the stream does not exist yet, <code>MKSTREAM</code> will create it automatically.</li>
</ul>
<hr>
<h2 id="what-it-creates" class="tsd-anchor-link">What it creates<a href="#what-it-creates" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>It executes the Redis command:</p>
<p><code>XGROUP CREATE &lt;queueName&gt; &lt;group&gt; &lt;from&gt; MKSTREAM</code></p>
<p>Where:</p>
<ul>
<li><code>&lt;queueName&gt;</code> is the Redis Stream key (your queue name).</li>
<li><code>&lt;group&gt;</code> is <code>this.group</code> (default in your class: <code>&quot;gr1&quot;</code>).</li>
<li><code>&lt;from&gt;</code> controls the <strong>starting point</strong> <em>only at the moment of group creation</em>.</li>
<li><code>MKSTREAM</code> makes Redis create an empty stream if it doesn't exist yet.</li>
</ul>
<hr>
<h2 id="parameters-3" class="tsd-anchor-link">Parameters<a href="#parameters-3" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key for the queue. Example: <code>&quot;alerts&quot;</code>, <code>&quot;emails&quot;</code>.</p>
</div></li><li><span><span class="tsd-kind-parameter">from</span>: <span class="tsd-signature-type">&quot;$&quot;</span> <span class="tsd-signature-symbol">|</span> <span class="tsd-signature-type">&quot;0-0&quot;</span><span class="tsd-signature-symbol"> = &#39;0-0&#39;</span></span><div class="tsd-comment tsd-typography"><p>Starting ID used <strong>only if the group is created now</strong>:</p>
<ul>
<li><code>&quot;$&quot;</code>: start from new messages only (ignore historical entries).</li>
<li><code>&quot;0-0&quot;</code>: start from the beginning of the stream (consume full history).</li>
</ul>
<p>If the group already exists, Redis ignores <code>from</code> (because the group’s position is already set).</p>
<hr>
<h2 id="error-handling-behavior" class="tsd-anchor-link">Error handling behavior<a href="#error-handling-behavior" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>
<p>If Redis returns an error that contains <code>&quot;BUSYGROUP&quot;</code>:
it means the consumer group already exists → this is not a real error → we do nothing.</p>
</li>
<li>
<p>Any other error is re-thrown because it likely indicates a real problem:</p>
<ul>
<li>permission issues / ACL restrictions</li>
<li>Redis connection issues</li>
<li>invalid stream name, etc.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="typical-usage" class="tsd-anchor-link">Typical usage<a href="#typical-usage" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>You usually don't call this manually; <a href="#runqueue" class="tsd-kind-method">runQueue</a> calls it before starting
<a href="#consumerloop" class="tsd-kind-method">consumerLoop</a>.</p>
<pre><code class="ts"><span class="hl-6">await</span><span class="hl-1"> </span><span class="hl-3">this</span><span class="hl-1">.</span><span class="hl-0">createGroup</span><span class="hl-1">(</span><span class="hl-2">&#39;alerts&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;$&#39;</span><span class="hl-1">);</span><br/><span class="hl-11">// now you can safely use XREADGROUP on &quot;alerts&quot; with group &quot;gr1&quot;</span>
</code><button type="button">Copy</button></pre>

</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4><p>Resolves when the group exists (either created now or already existed).</p>
<div class="tsd-comment tsd-typography"><div class="tsd-tag-throws"><h4 class="tsd-anchor-link" id="throws">Throws<a href="#throws" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><p>Re-throws any Redis error except <code>&quot;BUSYGROUP&quot;</code>.</p>
</div></div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L977">PowerQueues.ts:977</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="loadscripts"><span>load<wbr/>Scripts</span><a href="#loadscripts" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="loadscripts-1"><span class="tsd-kind-call-signature">loadScripts</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">full</span><span class="tsd-signature-symbol">?:</span> <span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span><a href="#loadscripts-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Load Lua scripts into Redis and cache their SHA1 hashes in memory.</p>
<p>Redis executes Lua scripts efficiently when they are loaded once and then referenced
by their SHA1 hash using <code>EVALSHA</code>. This method preloads the scripts used by this queue
implementation so that later calls (via runScript) are fast and reliable.</p>
<hr>
<h2 id="why-do-we-need-this" class="tsd-anchor-link">Why do we need this?<a href="#why-do-we-need-this" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>When you run a script in Redis, you have two main options:</p>
<ul>
<li><strong>EVAL</strong>: send the full Lua source code every time (slow + more network traffic).</li>
<li><strong>SCRIPT LOAD</strong> + <strong>EVALSHA</strong>: upload the script once, then call it by SHA (fast).</li>
</ul>
<p>This class uses the second approach:</p>
<ul>
<li><a href="#loadscripts" class="tsd-kind-method">loadScripts</a> uploads scripts using Redis <code>SCRIPT LOAD</code></li>
<li>runScript executes them using <code>EVALSHA</code></li>
</ul>
<p>If Redis is restarted, its script cache is cleared. In that case,
<code>EVALSHA</code> fails with <code>NOSCRIPT</code>, and runScript will automatically reload the script.
Still, preloading on startup is best practice because it reduces first-call latency.</p>
<hr>
<h2 id="parameters-4" class="tsd-anchor-link">Parameters<a href="#parameters-4" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">full</span>: <span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol"> = false</span></span><div class="tsd-comment tsd-typography"><p>Controls which scripts are loaded:</p>
<ul>
<li>
<p><code>false</code> (default): load only the minimal scripts needed to <strong>push tasks</strong> into the queue.
Currently it loads:</p>
<ul>
<li><code>XAddBulk</code> — a bulk <code>XADD</code> script used by <a href="#addtasks" class="tsd-kind-method">addTasks</a>.</li>
</ul>
</li>
<li>
<p><code>true</code>: load <strong>all scripts</strong> required for full worker operation (consume + ack + idempotency).
It loads:</p>
<ul>
<li><code>XAddBulk</code> — bulk producer script</li>
<li><code>Approve</code> — acknowledge / optionally remove executed messages</li>
<li><code>IdempotencyAllow</code> — idempotency gate (checks done/lock/start state)</li>
<li><code>IdempotencyStart</code> — acquire idempotency lock and mark start</li>
<li><code>IdempotencyDone</code> — mark done + cleanup lock/start</li>
<li><code>IdempotencyFree</code> — free lock/start on failure</li>
<li><code>SelectStuck</code> — select/reclaim stuck pending messages</li>
</ul>
</li>
</ul>
<hr>
<h2 id="when-should-you-call-it" class="tsd-anchor-link">When should you call it?<a href="#when-should-you-call-it" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>
<p>If you only use this class as a <strong>producer</strong> (only <a href="#addtasks" class="tsd-kind-method">addTasks</a>),
calling <code>loadScripts(false)</code> is enough.</p>
</li>
<li>
<p>If you run a <strong>worker</strong> (<a href="#runqueue" class="tsd-kind-method">runQueue</a>/<a href="#consumerloop" class="tsd-kind-method">consumerLoop</a>),
call <code>loadScripts(true)</code> once at startup.</p>
</li>
</ul>
<p>Example:</p>
<pre><code class="ts"><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-4">q</span><span class="hl-1"> = </span><span class="hl-3">new</span><span class="hl-1"> </span><span class="hl-0">PowerQueues</span><span class="hl-1">();</span><br/><span class="hl-5">q</span><span class="hl-1">.</span><span class="hl-5">redis</span><span class="hl-1"> = </span><span class="hl-5">redisClient</span><span class="hl-1">;</span><br/><br/><span class="hl-11">// For worker mode:</span><br/><span class="hl-6">await</span><span class="hl-1"> </span><span class="hl-5">q</span><span class="hl-1">.</span><span class="hl-0">loadScripts</span><span class="hl-1">(</span><span class="hl-3">true</span><span class="hl-1">);</span><br/><span class="hl-6">await</span><span class="hl-1"> </span><span class="hl-5">q</span><span class="hl-1">.</span><span class="hl-0">runQueue</span><span class="hl-1">(</span><span class="hl-2">&#39;alerts&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;$&#39;</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<hr>
<h2 id="what-this-method-does-internally" class="tsd-anchor-link">What this method does internally<a href="#what-this-method-does-internally" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ol>
<li>Builds a list of <code>[scriptName, luaCode]</code> pairs based on <code>full</code></li>
<li>For each script:
<ul>
<li>stores the Lua source code in <code>this.scripts</code> via saveScript</li>
<li>uploads it to Redis via loadScript (SCRIPT LOAD)</li>
</ul>
</li>
</ol>
<p>Note: <code>loadScript(this.saveScript(...))</code> looks a little unusual, but it is intentional:</p>
<ul>
<li><code>saveScript</code> registers the script locally (so runScript knows it exists)</li>
<li><code>loadScript</code> actually loads it into Redis and returns its SHA1
(the SHA1 returned by <code>loadScript</code> is not stored here directly; runScript
will store it lazily in <code>codeReady</code> when needed).</li>
</ul>
</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4><p>Resolves when all requested scripts have been uploaded to Redis successfully.</p>
<div class="tsd-comment tsd-typography"><div class="tsd-tag-throws"><h4 class="tsd-anchor-link" id="throws-1">Throws<a href="#throws-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><p>If Redis <code>SCRIPT LOAD</code> fails after retries inside loadScript.</p>
</div></div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L1714">PowerQueues.ts:1714</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="onbatcherror"><span>on<wbr/>Batch<wbr/>Error</span><a href="#onbatcherror" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="onbatcherror-1"><span class="tsd-kind-call-signature">onBatchError</span><span class="tsd-signature-symbol">(</span><br/>    <span class="tsd-kind-parameter">err</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">,</span><br/>    <span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span><br/>    <span class="tsd-kind-parameter">tasks</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-symbol">[</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">]</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">,</span><br/><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span><a href="#onbatcherror-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Hook that runs when <strong>batch-level processing</strong> fails inside <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a>.</p>
<p>A &quot;batch-level error&quot; means something threw while processing the batch pipeline, for example:</p>
<ul>
<li><a href="#beforeexecute" class="tsd-kind-method">beforeExecute</a> threw</li>
<li>execute threw (or something inside it bubbled up)</li>
<li>approve threw (ACK/removal script failed)</li>
</ul>
<p>When such error happens, <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a> calls batchError, and at the end of that
method it calls this hook:</p>
<p><code>await this.onBatchError(err, queueName, tasks)</code></p>
<p>This gives you one place to react to a failed batch:</p>
<ul>
<li>log the incident with context</li>
<li>export metrics</li>
<li>notify monitoring systems</li>
<li>dump debug information (carefully)</li>
</ul>
<hr>
<h2 id="important-retrydlq-logic-is-not-done-here" class="tsd-anchor-link">Important: retry/DLQ logic is NOT done here<a href="#important-retrydlq-logic-is-not-done-here" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>The core retry logic for batch errors lives in batchError itself:</p>
<ul>
<li>It groups failed tasks by <code>(attempt, createdAt, job)</code></li>
<li>Re-enqueues tasks if <code>attempt &lt; retryCount - 1</code></li>
<li>Otherwise (optionally) moves them to DLQ when <a href="#logstatus" class="tsd-kind-property">logStatus</a> is enabled</li>
</ul>
<p>This hook is called <strong>after</strong> that internal logic has been attempted.
So treat it as:
<strong>&quot;Batch failed; queue tried to handle it; you can observe/log/react.&quot;</strong></p>
<hr>
<h2 id="parameters-5" class="tsd-anchor-link">Parameters<a href="#parameters-5" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">err</span>: <span class="tsd-signature-type">any</span></span><div class="tsd-comment tsd-typography"><p>The error that caused the batch failure.
Usually an <code>Error</code>, but can be anything (<code>unknown</code>).</p>
</div></li><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key (queue name) being consumed.</p>
</div></li><li><span><span class="tsd-kind-parameter">tasks</span>: <span class="tsd-signature-symbol">[</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">]</span><span class="tsd-signature-symbol">[]</span></span><div class="tsd-comment tsd-typography"><p>The raw selected tasks that formed the batch at the time of failure.
Each item is a tuple:
<code>[ id, payload, createdAt, job, idemKey, attempt ]</code></p>
<p>Notes:</p>
<ul>
<li>This array may include tasks that were partially processed before the failure happened.</li>
<li><code>payload</code> is already parsed (JSON -&gt; object) by selectP when possible.</li>
</ul>
<hr>
<h2 id="return-value-2" class="tsd-anchor-link">Return value<a href="#return-value-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4><p>A promise that resolves when your hook logic is done.
Default implementation does nothing.</p>
<hr>
<h2 id="common-use-cases" class="tsd-anchor-link">Common use cases<a href="#common-use-cases" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Write one log line with batch size + job info</li>
<li>Emit a single alert for &quot;worker is unstable&quot; (instead of per-task alerts)</li>
<li>Track &quot;batch failures&quot; metric</li>
</ul>
<hr>
<h2 id="important-notes-for-overrides-1" class="tsd-anchor-link">Important notes for overrides<a href="#important-notes-for-overrides-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Be careful not to throw here. A throw inside this hook will be swallowed by
batchError (it already wraps it in a try/catch), but it may hide your real issue.</li>
<li>Avoid heavy I/O; this hook can be triggered during error storms.</li>
<li>Avoid logging entire payloads if they may contain secrets or personal data.</li>
</ul>
<hr>
<h2 id="example-override-log-batch-summary" class="tsd-anchor-link">Example override: log batch summary<a href="#example-override-log-batch-summary" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<pre><code class="ts"><span class="hl-5">override</span><span class="hl-1"> </span><span class="hl-5">async</span><span class="hl-1"> </span><span class="hl-0">onBatchError</span><span class="hl-1">(</span><span class="hl-5">err</span><span class="hl-1">: </span><span class="hl-5">any</span><span class="hl-1">, </span><span class="hl-5">queueName</span><span class="hl-1">: </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">tasks</span><span class="hl-1">: </span><span class="hl-5">Array</span><span class="hl-1">&lt;[</span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">any</span><span class="hl-1">, </span><span class="hl-5">number</span><span class="hl-1">, </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">number</span><span class="hl-1">]&gt;) {</span><br/><span class="hl-1">  </span><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-4">size</span><span class="hl-1"> = </span><span class="hl-5">tasks</span><span class="hl-1">.</span><span class="hl-5">length</span><span class="hl-1">;</span><br/><span class="hl-1">  </span><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-4">job</span><span class="hl-1"> = </span><span class="hl-5">size</span><span class="hl-1"> ? </span><span class="hl-0">String</span><span class="hl-1">(</span><span class="hl-5">tasks</span><span class="hl-1">[</span><span class="hl-7">0</span><span class="hl-1">][</span><span class="hl-7">3</span><span class="hl-1">]) : </span><span class="hl-2">&#39;unknown&#39;</span><span class="hl-1">;</span><br/><span class="hl-1">  </span><span class="hl-3">this</span><span class="hl-1">.</span><span class="hl-5">logger</span><span class="hl-1">.</span><span class="hl-0">error</span><span class="hl-1">(</span><span class="hl-2">`[</span><span class="hl-3">${</span><span class="hl-5">queueName</span><span class="hl-3">}</span><span class="hl-2">] batch error size=</span><span class="hl-3">${</span><span class="hl-5">size</span><span class="hl-3">}</span><span class="hl-2"> job=</span><span class="hl-3">${</span><span class="hl-5">job</span><span class="hl-3">}</span><span class="hl-2">`</span><span class="hl-1">, </span><span class="hl-5">err</span><span class="hl-1">);</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L2500">PowerQueues.ts:2500</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="onbatchready"><span>on<wbr/>Batch<wbr/>Ready</span><a href="#onbatchready" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="onbatchready-1"><span class="tsd-kind-call-signature">onBatchReady</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-kind-parameter">tasks</span><span class="tsd-signature-symbol">:</span> <a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span><a href="#onbatchready-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Hook that runs after a batch of tasks has been executed and the list of <strong>successful</strong>
tasks is ready.</p>
<p>This hook is called by execute right after all per-task executions finish
(either in parallel or sequentially depending on <a href="#executesync" class="tsd-kind-property">executeSync</a>).</p>
<p>Important: at the moment this hook is called, the tasks are:</p>
<ul>
<li>already processed successfully by <a href="#onexecute" class="tsd-kind-method">onExecute</a> (and idempotency marked as done),</li>
<li>but <strong>not yet acknowledged</strong> in Redis (ack happens later in <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a> via approve).</li>
</ul>
<p>So you can think of this hook as:
<strong>&quot;Batch succeeded logically, but not yet ACKed.&quot;</strong></p>
<hr>
<h2 id="what-is-in-the-batch" class="tsd-anchor-link">What is in the batch?<a href="#what-is-in-the-batch" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>The <code>tasks</code> parameter contains only tasks that were considered successful by executeProcess.
It does NOT include:</p>
<ul>
<li>contended tasks (idempotency lock was held by another worker),</li>
<li>tasks that threw errors,</li>
<li>tasks that were skipped due to idempotency states.</li>
</ul>
<hr>
<h2 id="why-this-hook-exists" class="tsd-anchor-link">Why this hook exists<a href="#why-this-hook-exists" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>It is useful for batch-level side effects that you want to perform once per batch, for example:</p>
<ul>
<li>logging summary: how many tasks were processed, which job, etc.</li>
<li>updating batch metrics / counters in your own monitoring system</li>
<li>emitting application-level events (&quot;N tasks processed&quot;)</li>
<li>flushing buffered data (if you accumulate results during per-task execution)</li>
</ul>
<hr>
<h2 id="parameters-6" class="tsd-anchor-link">Parameters<a href="#parameters-6" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key (queue name) being consumed.
Useful if one worker implementation handles multiple queues.</p>
</div></li><li><span><span class="tsd-kind-parameter">tasks</span>: <a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">[]</span></span><div class="tsd-comment tsd-typography"><p>Array of successfully processed tasks (instances of <a href="../types/Task.html" class="tsd-kind-type-alias">Task</a>).
Each task typically contains:</p>
<ul>
<li><code>id</code> — Redis stream entry id to be acknowledged later</li>
<li><code>payload</code> — your business payload</li>
<li><code>job</code>, <code>attempt</code>, <code>idemKey</code>, <code>createdAt</code> — metadata fields</li>
</ul>
<hr>
<h2 id="return-value-3" class="tsd-anchor-link">Return value<a href="#return-value-3" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4><p>A promise that resolves when your hook logic is done.
The default implementation does nothing.</p>
<hr>
<h2 id="important-notes-for-overrides-2" class="tsd-anchor-link">Important notes for overrides<a href="#important-notes-for-overrides-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Keep it <strong>fast</strong>: this runs for every batch.</li>
<li>If you throw here, the whole batch is treated as failed at the batch level
(because <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a> wraps the pipeline in a <code>try/catch</code>).
That means it may trigger batchError and retry logic even though tasks were executed.</li>
<li>Avoid heavy I/O or fragile logic here unless you're okay with batch-level failure behavior.</li>
<li>If you need &quot;after ACK&quot; behavior, place it after approve (override <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a>)
or do it inside <a href="#onsuccess" class="tsd-kind-method">onSuccess</a> per task.</li>
</ul>
<hr>
<h2 id="example-override-lightweight-metrics" class="tsd-anchor-link">Example override: lightweight metrics<a href="#example-override-lightweight-metrics" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<pre><code class="ts"><span class="hl-5">override</span><span class="hl-1"> </span><span class="hl-5">async</span><span class="hl-1"> </span><span class="hl-0">onBatchReady</span><span class="hl-1">(</span><span class="hl-5">queueName</span><span class="hl-1">: </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">tasks</span><span class="hl-1">: </span><span class="hl-5">Task</span><span class="hl-1">[]) {</span><br/><span class="hl-1">  </span><span class="hl-6">if</span><span class="hl-1"> (!</span><span class="hl-5">tasks</span><span class="hl-1">.</span><span class="hl-5">length</span><span class="hl-1">) </span><span class="hl-6">return</span><span class="hl-1">;</span><br/><span class="hl-1">  </span><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-4">job</span><span class="hl-1"> = </span><span class="hl-5">tasks</span><span class="hl-1">[</span><span class="hl-7">0</span><span class="hl-1">]?.</span><span class="hl-5">job</span><span class="hl-1">;</span><br/><span class="hl-1">  </span><span class="hl-3">this</span><span class="hl-1">.</span><span class="hl-5">logger</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-2">`[</span><span class="hl-3">${</span><span class="hl-5">queueName</span><span class="hl-3">}</span><span class="hl-2">] batch ok: </span><span class="hl-3">${</span><span class="hl-5">tasks</span><span class="hl-9">.</span><span class="hl-5">length</span><span class="hl-3">}</span><span class="hl-2"> tasks (job=</span><span class="hl-3">${</span><span class="hl-5">job</span><span class="hl-3">}</span><span class="hl-2">)`</span><span class="hl-1">);</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L2246">PowerQueues.ts:2246</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="onerror"><span>on<wbr/>Error</span><a href="#onerror" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="onerror-1"><span class="tsd-kind-call-signature">onError</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">err</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">,</span> <span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-kind-parameter">task</span><span class="tsd-signature-symbol">:</span> <a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">&gt;</span><a href="#onerror-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Hook that runs after a task processing attempt has failed.</p>
<p>This is the main failure callback for per-task errors.
It is called from error after the queue has already applied its internal
retry / DLQ logic:</p>
<ul>
<li>
<p>If retries are still allowed (<code>attempt &lt; retryCount - 1</code>):</p>
<ol>
<li><a href="#onretry" class="tsd-kind-method">onRetry</a> is called</li>
<li>the task is re-enqueued into the same queue with <code>attempt + 1</code></li>
</ol>
</li>
<li>
<p>If retries are exhausted and <a href="#logstatus" class="tsd-kind-property">logStatus</a> is enabled:</p>
<ol>
<li>error counters are incremented</li>
<li>the task is sent to the DLQ queue (<code>&lt;queueName&gt;:dlq</code>)</li>
</ol>
</li>
</ul>
<p>After that, <a href="#onerror" class="tsd-kind-method">onError</a> is called to let you log/notify/trace failures.</p>
<hr>
<h2 id="important-this-hook-does-not-mean-the-message-was-acked" class="tsd-anchor-link">Important: this hook does NOT mean &quot;the message was ACKed&quot;<a href="#important-this-hook-does-not-mean-the-message-was-acked" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>At the time <a href="#onerror" class="tsd-kind-method">onError</a> runs:</p>
<ul>
<li>the original Redis Stream entry is still pending until <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a> calls approve
(in the batch error path it tries to approve the original tasks best-effort),</li>
<li>but the retry/DLQ decision has already been made by the queue logic.</li>
</ul>
<p>So treat this hook as:
<strong>&quot;Task attempt failed; queue logic handled retry/DLQ; you can react to the failure.&quot;</strong></p>
<hr>
<h2 id="parameters-7" class="tsd-anchor-link">Parameters<a href="#parameters-7" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">err</span>: <span class="tsd-signature-type">any</span></span><div class="tsd-comment tsd-typography"><p>The error thrown by <a href="#onexecute" class="tsd-kind-method">onExecute</a> (or by idempotency/heartbeat logic around it).
It can be anything (string, Error, unknown), but usually it is an <code>Error</code>.</p>
</div></li><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key (queue name) the task came from.</p>
</div></li><li><span><span class="tsd-kind-parameter">task</span>: <a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a></span><div class="tsd-comment tsd-typography"><p>The task that failed.
Note: in the current implementation, <code>task.attempt</code> passed to this hook is usually
incremented (<code>attempt + 1</code>) when returning from error, so you can treat it as:</p>
<ul>
<li>&quot;the next attempt number&quot; (what the retry will be),
rather than &quot;the attempt that just failed&quot;.</li>
</ul>
<p>Fields:</p>
<ul>
<li><code>task.payload</code> — your payload that caused the failure</li>
<li><code>task.job</code> — job identifier</li>
<li><code>task.attempt</code> — next attempt number (see note above)</li>
<li><code>task.idemKey</code> — idempotency key</li>
<li><code>task.id</code> — Redis stream entry id</li>
</ul>
<hr>
<h2 id="return-value-4" class="tsd-anchor-link">Return value<a href="#return-value-4" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">&gt;</span></h4><p>A promise that resolves to a <a href="../types/Task.html" class="tsd-kind-type-alias">Task</a>.</p>
<p>The returned value is used by executeProcess to decide whether the original
stream entry should be acknowledged:</p>
<ul>
<li>execute collects returned tasks as processed results</li>
<li>then <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a> passes them to approve</li>
</ul>
<p>In this implementation, error returns the result of <a href="#onerror" class="tsd-kind-method">onError</a>.
That means: if your override returns the task <strong>with a valid <code>id</code></strong>, the system may
treat it as &quot;processable result&quot; and attempt to acknowledge it later.</p>
<p>Practical rule:</p>
<ul>
<li>If you want the failed entry to be acknowledged (common, because retry was re-enqueued),
return the task unchanged (keep <code>id</code>).</li>
<li>If you want to leave it pending for some reason, you could return an object without <code>id</code>,
but this is advanced and can cause stuck/pending behavior.</li>
</ul>
<hr>
<h2 id="common-use-cases-1" class="tsd-anchor-link">Common use cases<a href="#common-use-cases-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>log the error with context (queueName, job, attempt, idemKey, payload summary)</li>
<li>send error notifications (Telegram, email, Sentry)</li>
<li>implement custom metrics for failures</li>
</ul>
<hr>
<h2 id="important-notes-for-overrides-3" class="tsd-anchor-link">Important notes for overrides<a href="#important-notes-for-overrides-3" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Do not throw inside this hook if you can avoid it.
Throwing here can break batch flow and cause extra retries.</li>
<li>Avoid logging full payloads if they may contain sensitive data.</li>
<li>If you need different behavior for &quot;final failure&quot; vs &quot;will retry&quot;,
check <code>task.attempt</code> against <code>this.retryCount</code>.</li>
</ul>
<hr>
<h2 id="example-override-sentry-structured-logging" class="tsd-anchor-link">Example override: Sentry + structured logging<a href="#example-override-sentry-structured-logging" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<pre><code class="ts"><span class="hl-5">override</span><span class="hl-1"> </span><span class="hl-5">async</span><span class="hl-1"> </span><span class="hl-0">onError</span><span class="hl-1">(</span><span class="hl-5">err</span><span class="hl-1">: </span><span class="hl-5">any</span><span class="hl-1">, </span><span class="hl-5">queueName</span><span class="hl-1">: </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">task</span><span class="hl-1">: </span><span class="hl-5">Task</span><span class="hl-1">): </span><span class="hl-8">Promise</span><span class="hl-1">&lt;</span><span class="hl-5">Task</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">  this.logger.error(</span><span class="hl-2">`[</span><span class="hl-3">${</span><span class="hl-5">queueName</span><span class="hl-3">}</span><span class="hl-2">] failed job=</span><span class="hl-3">${</span><span class="hl-5">task</span><span class="hl-9">.</span><span class="hl-5">job</span><span class="hl-3">}</span><span class="hl-2"> attempt=</span><span class="hl-3">${</span><span class="hl-5">task</span><span class="hl-9">.</span><span class="hl-5">attempt</span><span class="hl-3">}</span><span class="hl-2"> id=</span><span class="hl-3">${</span><span class="hl-5">task</span><span class="hl-9">.</span><span class="hl-5">id</span><span class="hl-3">}</span><span class="hl-2">`</span><span class="hl-1">, err);</span><br/><span class="hl-1">  Sentry.captureException(</span><span class="hl-5">err</span><span class="hl-1">, { </span><span class="hl-12">extra</span><span class="hl-1">: { </span><span class="hl-5">queueName</span><span class="hl-1">, </span><span class="hl-5">task</span><span class="hl-1"> } });</span><br/><span class="hl-1">  return task; </span><span class="hl-11">// keep id so original entry can be ACKed</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L2417">PowerQueues.ts:2417</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="onexecute"><span>on<wbr/>Execute</span><a href="#onexecute" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="onexecute-1"><span class="tsd-kind-call-signature">onExecute</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-kind-parameter">task</span><span class="tsd-signature-symbol">:</span> <a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">&gt;</span><a href="#onexecute-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Execute a single task.</p>
<p>This is the <strong>main business-logic hook</strong> of the queue system.
By default it does nothing and returns the task unchanged, but in real projects
you override this method to perform the actual work (send a message, call an API,
write to a database, etc.).</p>
<p>This method is called from inside executeProcess, which wraps it with:</p>
<ul>
<li><strong>idempotency control</strong> (so duplicate deliveries don't cause duplicate side effects)</li>
<li><strong>heartbeat</strong> (keeps the idempotency lock alive for long-running tasks)</li>
<li>error handling and retry / DLQ logic</li>
</ul>
<hr>
<h2 id="where-it-sits-in-the-pipeline" class="tsd-anchor-link">Where it sits in the pipeline<a href="#where-it-sits-in-the-pipeline" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>A typical worker iteration looks like this:</p>
<p><code>select() -&gt; beforeExecute() -&gt; execute() -&gt; executeProcess() -&gt; onExecute() -&gt; approve()</code></p>
<p>And inside <code>executeProcess()</code>:</p>
<ol>
<li>Check idempotency (allow/start)</li>
<li>Start heartbeat (optional)</li>
<li>Call <a href="#onexecute" class="tsd-kind-method">onExecute</a></li>
<li>Mark idempotency as done</li>
<li>Acknowledge the message (via approve)</li>
</ol>
<p>If <a href="#onexecute" class="tsd-kind-method">onExecute</a> throws, the task is treated as failed and will go through retry/DLQ rules.</p>
<hr>
<h2 id="parameters-8" class="tsd-anchor-link">Parameters<a href="#parameters-8" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key (queue name) the task came from.
Useful if the same worker class processes multiple queues.</p>
</div></li><li><span><span class="tsd-kind-parameter">task</span>: <a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a></span><div class="tsd-comment tsd-typography"><p>The task to execute.</p>
<p>Fields you typically use:</p>
<ul>
<li><code>task.payload</code> — your business payload (object/string/whatever you put in <a href="#addtasks" class="tsd-kind-method">addTasks</a>)</li>
<li><code>task.job</code> — job identifier (useful for grouping/metrics)</li>
<li><code>task.attempt</code> — retry attempt number (0 for first try)</li>
<li><code>task.idemKey</code> — idempotency key (important for exactly-once side effects)</li>
<li><code>task.id</code> — Redis stream entry id (useful for logs/debugging)</li>
<li><code>task.createdAt</code> — timestamp stored when the task was created</li>
</ul>
<hr>
<h2 id="return-value-5" class="tsd-anchor-link">Return value<a href="#return-value-5" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">&gt;</span></h4><p>A promise that resolves to a <a href="../types/Task.html" class="tsd-kind-type-alias">Task</a>.</p>
<p>Usually you should return the same task (possibly enriched) because:</p>
<ul>
<li>execute collects returned tasks as &quot;successfully processed&quot;</li>
<li>and passes them to approve so they can be acknowledged in Redis.</li>
</ul>
<p>If you return the task unchanged, that's perfectly fine.</p>
<hr>
<h2 id="how-to-signal-failure" class="tsd-anchor-link">How to signal failure<a href="#how-to-signal-failure" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>To mark the task as failed, throw an error:</p>
<pre><code class="ts"><span class="hl-6">throw</span><span class="hl-1"> </span><span class="hl-3">new</span><span class="hl-1"> </span><span class="hl-0">Error</span><span class="hl-1">(</span><span class="hl-2">&#39;Something went wrong&#39;</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The queue will then:</p>
<ul>
<li>call idempotencyFree</li>
<li>call <a href="#onretry" class="tsd-kind-method">onRetry</a> + re-enqueue (if attempts remain)</li>
<li>or put into DLQ (if enabled and attempts exhausted)</li>
<li>call <a href="#onerror" class="tsd-kind-method">onError</a></li>
</ul>
<hr>
<h2 id="important-notes-for-overrides-practical-advice" class="tsd-anchor-link">Important notes for overrides (practical advice)<a href="#important-notes-for-overrides-practical-advice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Make this method <strong>idempotent</strong> if possible (safe to run twice).
Even with locks, real systems can still deliver duplicates due to retries/network issues.</li>
<li>Use <code>task.attempt</code> to implement backoff logic if needed.</li>
<li>Keep the method focused: do business logic here, and put logging/metrics into
<a href="#onsuccess" class="tsd-kind-method">onSuccess</a>/<a href="#onerror" class="tsd-kind-method">onError</a>/<a href="#onretry" class="tsd-kind-method">onRetry</a> if you prefer.</li>
</ul>
<hr>
<h2 id="example-override-send-telegram-message" class="tsd-anchor-link">Example override: send Telegram message<a href="#example-override-send-telegram-message" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<pre><code class="ts"><span class="hl-5">override</span><span class="hl-1"> </span><span class="hl-5">async</span><span class="hl-1"> </span><span class="hl-0">onExecute</span><span class="hl-1">(</span><span class="hl-5">queueName</span><span class="hl-1">: </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">task</span><span class="hl-1">: </span><span class="hl-5">Task</span><span class="hl-1">): </span><span class="hl-8">Promise</span><span class="hl-1">&lt;</span><span class="hl-5">Task</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">  const { </span><span class="hl-5">telegramChatId</span><span class="hl-1">, </span><span class="hl-5">text</span><span class="hl-1"> } = task.payload;</span><br/><br/><span class="hl-1">  </span><span class="hl-0">if</span><span class="hl-1"> (!</span><span class="hl-5">telegramChatId</span><span class="hl-1"> || !</span><span class="hl-5">text</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-6">throw</span><span class="hl-1"> </span><span class="hl-3">new</span><span class="hl-1"> </span><span class="hl-0">Error</span><span class="hl-1">(</span><span class="hl-2">&#39;Invalid payload: telegramChatId and text are required&#39;</span><span class="hl-1">);</span><br/><span class="hl-1">  }</span><br/><br/><span class="hl-1">  await this.telegramService.sendMessage(</span><span class="hl-5">telegramChatId</span><span class="hl-1">, text);</span><br/><span class="hl-1">  return task;</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L2170">PowerQueues.ts:2170</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="onretry"><span>on<wbr/>Retry</span><a href="#onretry" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="onretry-1"><span class="tsd-kind-call-signature">onRetry</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">err</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">,</span> <span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-kind-parameter">task</span><span class="tsd-signature-symbol">:</span> <a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span><a href="#onretry-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Hook that runs right before a failed task is re-enqueued for another attempt.</p>
<p>This hook is called from error only when the queue decides that the task
<strong>should be retried</strong>:</p>
<p>Condition in your code:
<code>if (!(task.attempt &gt;= (this.retryCount - 1))) { ... retry ... }</code></p>
<p>That means:</p>
<ul>
<li>the current attempt failed,</li>
<li>and there are still retry attempts remaining.</li>
</ul>
<p>The hook is executed <em>before</em> the task is added back into the queue with <code>attempt + 1</code>.</p>
<hr>
<h2 id="when-exactly-it-happens-in-the-flow" class="tsd-anchor-link">When exactly it happens in the flow<a href="#when-exactly-it-happens-in-the-flow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Failure flow inside executeProcess:</p>
<ol>
<li><a href="#onexecute" class="tsd-kind-method">onExecute</a> throws</li>
<li>queue frees idempotency lock via idempotencyFree</li>
<li>error decides retry vs DLQ</li>
<li>if retry:
<ul>
<li>call <a href="#onretry" class="tsd-kind-method">onRetry</a> (this hook)</li>
<li>call <a href="#addtasks" class="tsd-kind-method">addTasks</a> with the same payload and <code>attempt + 1</code></li>
</ul>
</li>
<li>finally call <a href="#onerror" class="tsd-kind-method">onError</a> (after retry/DLQ decision and actions)</li>
</ol>
<p>So <a href="#onretry" class="tsd-kind-method">onRetry</a> is a great place to:</p>
<ul>
<li>log &quot;retry scheduled&quot;</li>
<li>apply external backoff metadata</li>
<li>send a lightweight notification (or metrics)</li>
</ul>
<hr>
<h2 id="parameters-9" class="tsd-anchor-link">Parameters<a href="#parameters-9" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">err</span>: <span class="tsd-signature-type">any</span></span><div class="tsd-comment tsd-typography"><p>The error that caused the failure (thrown by <a href="#onexecute" class="tsd-kind-method">onExecute</a> or wrapper logic).</p>
</div></li><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key (queue name) the task belongs to.</p>
</div></li><li><span><span class="tsd-kind-parameter">task</span>: <a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a></span><div class="tsd-comment tsd-typography"><p>The task that failed and is going to be retried.</p>
<p>Important note about <code>attempt</code>:</p>
<ul>
<li>The <code>task.attempt</code> here is the <strong>attempt that just failed</strong>.</li>
<li>The queue will re-enqueue the task with <code>attempt + 1</code>.</li>
</ul>
<p>Fields you may use:</p>
<ul>
<li><code>task.payload</code> — original payload</li>
<li><code>task.job</code> — job identifier</li>
<li><code>task.attempt</code> — current failed attempt</li>
<li><code>task.idemKey</code> — idempotency key</li>
<li><code>task.id</code> — Redis stream entry id (original message id)</li>
</ul>
<hr>
<h2 id="return-value-6" class="tsd-anchor-link">Return value<a href="#return-value-6" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4><p>A promise that resolves when your hook logic is done.
The default implementation does nothing.</p>
<hr>
<h2 id="common-use-cases-2" class="tsd-anchor-link">Common use cases<a href="#common-use-cases-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Structured logging for retries</li>
<li>Retry metrics: increment counters by job or queue name</li>
<li>Add custom backoff hints into your payload (advanced; but remember the payload
that gets re-enqueued is <code>{ ...task.payload }</code> from error)</li>
</ul>
<hr>
<h2 id="important-notes-for-overrides-4" class="tsd-anchor-link">Important notes for overrides<a href="#important-notes-for-overrides-4" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Avoid throwing here. If this hook throws, the retry will still likely happen,
but you may lose observability and complicate error storms.</li>
<li>Keep it lightweight; it can be called frequently if downstream systems are unstable.</li>
<li>Do not rely on this hook to <em>schedule delays</em>. This implementation re-enqueues immediately.
If you need delayed retries, you typically implement separate &quot;delay queues&quot; or
store <code>runAt</code> and skip until time inside <a href="#beforeexecute" class="tsd-kind-method">beforeExecute</a> / <a href="#onexecute" class="tsd-kind-method">onExecute</a>.</li>
</ul>
<hr>
<h2 id="example-override-log-retry-scheduling" class="tsd-anchor-link">Example override: log retry scheduling<a href="#example-override-log-retry-scheduling" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<pre><code class="ts"><span class="hl-5">override</span><span class="hl-1"> </span><span class="hl-5">async</span><span class="hl-1"> </span><span class="hl-0">onRetry</span><span class="hl-1">(</span><span class="hl-5">err</span><span class="hl-1">: </span><span class="hl-5">any</span><span class="hl-1">, </span><span class="hl-5">queueName</span><span class="hl-1">: </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">task</span><span class="hl-1">: </span><span class="hl-5">Task</span><span class="hl-1">) {</span><br/><span class="hl-1">  </span><span class="hl-3">this</span><span class="hl-1">.</span><span class="hl-5">logger</span><span class="hl-1">.</span><span class="hl-0">warn</span><span class="hl-1">(</span><br/><span class="hl-1">    </span><span class="hl-2">`[</span><span class="hl-3">${</span><span class="hl-5">queueName</span><span class="hl-3">}</span><span class="hl-2">] retry scheduled job=</span><span class="hl-3">${</span><span class="hl-5">task</span><span class="hl-9">.</span><span class="hl-5">job</span><span class="hl-3">}</span><span class="hl-2"> attempt=</span><span class="hl-3">${</span><span class="hl-5">task</span><span class="hl-9">.</span><span class="hl-5">attempt</span><span class="hl-3">}</span><span class="hl-2"> -&gt; </span><span class="hl-3">${</span><span class="hl-5">task</span><span class="hl-9">.</span><span class="hl-5">attempt</span><span class="hl-9"> </span><span class="hl-1">+</span><span class="hl-9"> </span><span class="hl-7">1</span><span class="hl-3">}</span><span class="hl-2"> id=</span><span class="hl-3">${</span><span class="hl-5">task</span><span class="hl-9">.</span><span class="hl-5">id</span><span class="hl-3">}</span><span class="hl-2">`</span><span class="hl-1">,</span><br/><span class="hl-1">  );</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L2591">PowerQueues.ts:2591</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="onsuccess"><span>on<wbr/>Success</span><a href="#onsuccess" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="onsuccess-1"><span class="tsd-kind-call-signature">onSuccess</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-kind-parameter">task</span><span class="tsd-signature-symbol">:</span> <a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">&gt;</span><a href="#onsuccess-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Hook that runs after a task has been processed successfully.</p>
<p>This hook is called from success, which itself is called after:</p>
<ol>
<li><a href="#onexecute" class="tsd-kind-method">onExecute</a> finished without throwing,</li>
<li>idempotency state was marked as &quot;done&quot; via idempotencyDone,</li>
<li>(optionally) internal success counters were updated when <a href="#logstatus" class="tsd-kind-property">logStatus</a> is enabled.</li>
</ol>
<p>Important: when this hook runs, the task is <strong>logically successful</strong>,
but the Redis Stream entry may still not be acknowledged yet.
Acknowledgment happens later in <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a> via approve.</p>
<p>So you can think of <a href="#onsuccess" class="tsd-kind-method">onSuccess</a> as:
<strong>&quot;Task succeeded, ACK will happen right after the batch completes.&quot;</strong></p>
<hr>
<h2 id="parameters-10" class="tsd-anchor-link">Parameters<a href="#parameters-10" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key (queue name) the task came from.</p>
</div></li><li><span><span class="tsd-kind-parameter">task</span>: <a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a></span><div class="tsd-comment tsd-typography"><p>Successfully processed task.
Typical fields:</p>
<ul>
<li><code>task.payload</code> — your business payload</li>
<li><code>task.job</code> — job identifier</li>
<li><code>task.attempt</code> — attempt number (0 means first try)</li>
<li><code>task.idemKey</code> — idempotency key</li>
<li><code>task.id</code> — Redis stream entry id (useful for debugging)</li>
<li><code>task.createdAt</code> — creation timestamp (ms)</li>
</ul>
<hr>
<h2 id="return-value-7" class="tsd-anchor-link">Return value<a href="#return-value-7" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><a href="../types/Task.html" class="tsd-signature-type tsd-kind-type-alias">Task</a><span class="tsd-signature-symbol">&gt;</span></h4><p>A promise that resolves to a <a href="../types/Task.html" class="tsd-kind-type-alias">Task</a>.</p>
<p>The returned task object is what execute collects and passes to approve.
For correct behavior you should usually return the same task (or a slightly enriched copy)
and keep <code>task.id</code> intact, because approve needs it to acknowledge the message.</p>
<hr>
<h2 id="common-use-cases-3" class="tsd-anchor-link">Common use cases<a href="#common-use-cases-3" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Override this method to implement side effects that should happen on successful processing,
for example:</p>
<ul>
<li>logging (per task)</li>
<li>pushing metrics (Prometheus, StatsD, etc.)</li>
<li>emitting events to your application</li>
<li>collecting additional data for debugging/auditing</li>
</ul>
<hr>
<h2 id="important-notes-for-overrides-5" class="tsd-anchor-link">Important notes for overrides<a href="#important-notes-for-overrides-5" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Keep it <strong>fast</strong>: this runs for every successful task.</li>
<li>If you throw here, the whole batch can be treated as failed by <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a>,
which may trigger batchError even though <a href="#onexecute" class="tsd-kind-method">onExecute</a> succeeded.
Prefer not to throw; log errors instead.</li>
<li>If you need to do something only after Redis ACK has happened,
do it after approve (override <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a>) or move logic elsewhere.</li>
</ul>
<hr>
<h2 id="example-override-per-task-logging" class="tsd-anchor-link">Example override: per-task logging<a href="#example-override-per-task-logging" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<pre><code class="ts"><span class="hl-5">override</span><span class="hl-1"> </span><span class="hl-5">async</span><span class="hl-1"> </span><span class="hl-0">onSuccess</span><span class="hl-1">(</span><span class="hl-5">queueName</span><span class="hl-1">: </span><span class="hl-5">string</span><span class="hl-1">, </span><span class="hl-5">task</span><span class="hl-1">: </span><span class="hl-5">Task</span><span class="hl-1">): </span><span class="hl-8">Promise</span><span class="hl-1">&lt;</span><span class="hl-5">Task</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">  this.logger.log(</span><span class="hl-2">`[</span><span class="hl-3">${</span><span class="hl-5">queueName</span><span class="hl-3">}</span><span class="hl-2">] ok id=</span><span class="hl-3">${</span><span class="hl-5">task</span><span class="hl-9">.</span><span class="hl-5">id</span><span class="hl-3">}</span><span class="hl-2"> job=</span><span class="hl-3">${</span><span class="hl-5">task</span><span class="hl-9">.</span><span class="hl-5">job</span><span class="hl-3">}</span><span class="hl-2"> attempt=</span><span class="hl-3">${</span><span class="hl-5">task</span><span class="hl-9">.</span><span class="hl-5">attempt</span><span class="hl-3">}</span><span class="hl-2">`</span><span class="hl-5">);</span><br/><span class="hl-5">  return task;</span><br/><span class="hl-5">}</span>
</code><button type="button">Copy</button></pre>

<aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L2317">PowerQueues.ts:2317</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="runqueue"><span>run<wbr/>Queue</span><a href="#runqueue" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="runqueue-1"><span class="tsd-kind-call-signature">runQueue</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-kind-parameter">from</span><span class="tsd-signature-symbol">?:</span> <span class="tsd-signature-type">&quot;$&quot;</span> <span class="tsd-signature-symbol">|</span> <span class="tsd-signature-type">&quot;0-0&quot;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span><a href="#runqueue-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Start consuming a Redis Stream queue with a consumer group and keep processing messages
until the queue is stopped via abort.</p>
<p>This method is the <strong>main entry point</strong> to run a queue worker:</p>
<ol>
<li>It ensures a <strong>consumer group</strong> exists for the given stream (queue).</li>
<li>It starts an <strong>infinite consume loop</strong> that reads tasks from Redis Streams and executes them.</li>
<li>It can be stopped gracefully by calling <code>this.abort.abort()</code>.</li>
</ol>
<hr>
<h2 id="what-is-a-queue-here" class="tsd-anchor-link">What is a &quot;queue&quot; here?<a href="#what-is-a-queue-here" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>In this library a queue is implemented as a <strong>Redis Stream</strong>.</p>
<ul>
<li><code>queueName</code> is the stream key in Redis.</li>
<li>Tasks are stored as stream entries.</li>
</ul>
<h2 id="what-is-a-consumer-group-1" class="tsd-anchor-link">What is a &quot;consumer group&quot;?<a href="#what-is-a-consumer-group-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Redis Streams consumer groups allow multiple workers to consume the same stream
without processing the same message twice.</p>
<ul>
<li><code>this.group</code> is the consumer group name (default: <code>&quot;gr1&quot;</code>).</li>
<li><code>this.consumer()</code> returns a unique consumer id (default: <code>&quot;host:&lt;pid&gt;&quot;</code>).</li>
</ul>
<hr>
<h2 id="parameters-11" class="tsd-anchor-link">Parameters<a href="#parameters-11" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key to consume from (e.g. <code>&quot;emails&quot;</code>, <code>&quot;alerts&quot;</code>, <code>&quot;payments&quot;</code>).
Must be a valid Redis key. If it doesn't exist yet, it will be created automatically
(because <code>createGroup()</code> uses <code>MKSTREAM</code>).</p>
</div></li><li><span><span class="tsd-kind-parameter">from</span>: <span class="tsd-signature-type">&quot;$&quot;</span> <span class="tsd-signature-symbol">|</span> <span class="tsd-signature-type">&quot;0-0&quot;</span><span class="tsd-signature-symbol"> = &#39;0-0&#39;</span></span><div class="tsd-comment tsd-typography"><p>Where to start the consumer group if it is being created right now:</p>
<ul>
<li><code>&quot;$&quot;</code> (recommended for production): start from <strong>new messages only</strong> (ignore old history).</li>
<li><code>&quot;0-0&quot;</code> (useful for dev/backfills): start from the <strong>beginning of the stream</strong>.</li>
</ul>
<p>Important:</p>
<ul>
<li><code>from</code> is only used when the group is created. If the group already exists,
Redis will continue from where it left off (pending/last delivered), regardless of <code>from</code>.</li>
</ul>
<p>Default is <code>&quot;0-0&quot;</code> in this code, which means &quot;start from the very beginning&quot;
on first creation of the group.</p>
<hr>
<h2 id="how-it-works-internally" class="tsd-anchor-link">How it works internally<a href="#how-it-works-internally" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<h3 id="1-remove-listener-limits-for-abortsignal" class="tsd-anchor-link">1) Remove listener limits for AbortSignal<a href="#1-remove-listener-limits-for-abortsignal" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3>
<p><code>setMaxListeners(0, this.abort.signal)</code> disables the warning about &quot;MaxListenersExceededWarning&quot;.
This is useful because the worker loop may attach abort listeners multiple times
(for example inside waitAbortable), and we don't want Node.js to treat that as a leak.</p>
<h3 id="2-create-the-consumer-group-if-missing" class="tsd-anchor-link">2) Create the consumer group (if missing)<a href="#2-create-the-consumer-group-if-missing" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3>
<p><a href="#creategroup" class="tsd-kind-method">createGroup</a> calls:
<code>XGROUP CREATE &lt;queueName&gt; &lt;group&gt; &lt;from&gt; MKSTREAM</code></p>
<ul>
<li>If the group already exists, Redis replies with <code>BUSYGROUP</code> → we ignore it.</li>
<li>If the stream doesn't exist, <code>MKSTREAM</code> creates it automatically.</li>
</ul>
<h3 id="3-start-the-consumer-loop" class="tsd-anchor-link">3) Start the consumer loop<a href="#3-start-the-consumer-loop" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3>
<p><a href="#consumerloop" class="tsd-kind-method">consumerLoop</a> is an infinite loop that:</p>
<ul>
<li>Reads tasks (first tries &quot;stuck&quot; tasks, then reads new ones)</li>
<li>Parses entries into your internal tuple format</li>
<li>Calls <a href="#beforeexecute" class="tsd-kind-method">beforeExecute</a> (hook)</li>
<li>Executes tasks via <a href="#onexecute" class="tsd-kind-method">onExecute</a> (hook) with idempotency + heartbeat</li>
<li>Acknowledges (approves) successfully handled entries via Lua script <code>Approve</code></li>
<li>Handles failures with retry / DLQ logic via batchError</li>
</ul>
<p>The loop runs until <code>this.abort.abort()</code> is called (i.e. until <code>AbortSignal.aborted === true</code>).</p>
<hr>
<h2 id="typical-usage-1" class="tsd-anchor-link">Typical usage<a href="#typical-usage-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<pre><code class="ts"><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-4">q</span><span class="hl-1"> = </span><span class="hl-3">new</span><span class="hl-1"> </span><span class="hl-0">PowerQueues</span><span class="hl-1">();</span><br/><span class="hl-5">q</span><span class="hl-1">.</span><span class="hl-5">redis</span><span class="hl-1"> = </span><span class="hl-5">redisClient</span><span class="hl-1">;</span><br/><span class="hl-6">await</span><span class="hl-1"> </span><span class="hl-5">q</span><span class="hl-1">.</span><span class="hl-0">loadScripts</span><span class="hl-1">(</span><span class="hl-3">true</span><span class="hl-1">);</span><br/><br/><span class="hl-11">// Start worker for &quot;alerts&quot; queue. New messages only:</span><br/><span class="hl-6">await</span><span class="hl-1"> </span><span class="hl-5">q</span><span class="hl-1">.</span><span class="hl-0">runQueue</span><span class="hl-1">(</span><span class="hl-2">&#39;alerts&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;$&#39;</span><span class="hl-1">);</span><br/><br/><span class="hl-11">// ...later, to stop:</span><br/><span class="hl-5">q</span><span class="hl-1">.</span><span class="hl-5">abort</span><span class="hl-1">.</span><span class="hl-0">abort</span><span class="hl-1">();</span>
</code><button type="button">Copy</button></pre>

<hr>
<h2 id="notes-best-practices-1" class="tsd-anchor-link">Notes &amp; best practices<a href="#notes-best-practices-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<ul>
<li>Prefer <code>from = '$'</code> for long-running production workers to avoid consuming historical data
when a group is created for the first time.</li>
<li>Use <code>&quot;0-0&quot;</code> only when you really want to process the entire stream history.</li>
<li>To run multiple workers for the same queue, start multiple processes/containers.
Each process will have a different <code>consumer()</code> value because it includes <code>process.pid</code>.</li>
</ul>
</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4><p>A promise that resolves only when the loop stops (i.e., when aborted).
In normal operation it runs forever.</p>
<div class="tsd-comment tsd-typography"><div class="tsd-tag-throws"><h4 class="tsd-anchor-link" id="throws-2">Throws<a href="#throws-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><p>Any error from <a href="#creategroup" class="tsd-kind-method">createGroup</a> that is not a &quot;BUSYGROUP&quot; error.
Other errors inside the consume loop are handled internally and do not crash the worker by design.</p>
</div></div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L910">PowerQueues.ts:910</a></li></ul></aside></div></li></ul></section><section class="tsd-panel tsd-member"><h3 class="tsd-anchor-link" id="select"><span>select</span><a href="#select" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul class="tsd-signatures"><li class=""><div class="tsd-signature tsd-anchor-link" id="select-1"><span class="tsd-kind-call-signature">select</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">queueName</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">,</span> <span class="tsd-kind-parameter">from</span><span class="tsd-signature-symbol">?:</span> <span class="tsd-signature-type">&quot;$&quot;</span> <span class="tsd-signature-symbol">|</span> <span class="tsd-signature-type">&quot;0-0&quot;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">&gt;</span><a href="#select-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></div><div class="tsd-description"><div class="tsd-comment tsd-typography"><p>Select (read) a batch of tasks from the queue (Redis Stream).</p>
<p>This method is a <strong>high-level read operation</strong> used by <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a>.
It combines two different read strategies:</p>
<ol>
<li>Try to get <strong>stuck / pending</strong> messages first (messages that were delivered earlier
but were not acknowledged due to a crash, timeout, or worker failure).</li>
<li>If there are no stuck messages, read <strong>new</strong> messages from the stream using <code>XREADGROUP</code>.</li>
<li>Normalize and parse the raw Redis response into an internal tuple format.</li>
</ol>
<p>The return value is always an array of tuples:
<code>[ id, payload, createdAt, job, idemKey, attempt ]</code></p>
<hr>
<h2 id="why-stuck-first" class="tsd-anchor-link">Why &quot;stuck first&quot;?<a href="#why-stuck-first" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Redis Streams consumer groups keep unacknowledged messages in a Pending Entries List (PEL).
If a worker dies after receiving a message but before acknowledging it,
that message becomes &quot;pending&quot; and will not be delivered again as a &quot;new&quot; message (<code>&gt;</code>).</p>
<p>To avoid losing such messages, we intentionally:</p>
<ul>
<li>first attempt to reclaim/collect stuck pending messages via selectS,</li>
<li>and only then read brand-new messages via selectF.</li>
</ul>
<p>This gives your queue <strong>at-least-once</strong> delivery behavior.</p>
<hr>
<h2 id="parameters-12" class="tsd-anchor-link">Parameters<a href="#parameters-12" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
</div><div class="tsd-parameters"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameter-list"><li><span><span class="tsd-kind-parameter">queueName</span>: <span class="tsd-signature-type">string</span></span><div class="tsd-comment tsd-typography"><p>Redis Stream key (queue) to read from.</p>
</div></li><li><span><span class="tsd-kind-parameter">from</span>: <span class="tsd-signature-type">&quot;$&quot;</span> <span class="tsd-signature-symbol">|</span> <span class="tsd-signature-type">&quot;0-0&quot;</span><span class="tsd-signature-symbol"> = &#39;0-0&#39;</span></span><div class="tsd-comment tsd-typography"><p>Used only for recovery if the consumer group is missing (<code>NOGROUP</code>).
In that case we call <a href="#creategroup" class="tsd-kind-method">(queueName, from)</a>.
See <a href="#creategroup" class="tsd-kind-method">createGroup</a> for details.</p>
<p>Default: <code>&quot;0-0&quot;</code>.</p>
<hr>
<h2 id="return-value-format" class="tsd-anchor-link">Return value format<a href="#return-value-format" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>Each returned item is:</p>
<ul>
<li><code>id</code> (string): Redis Stream entry id (e.g. <code>&quot;1700000000000-0&quot;</code>).</li>
<li><code>payload</code> (any): Parsed JSON payload (or raw string if JSON parsing fails).</li>
<li><code>createdAt</code> (number): Timestamp stored in message fields (expected ms).</li>
<li><code>job</code> (string): Job identifier stored in message fields.</li>
<li><code>idemKey</code> (string): Idempotency key stored in message fields.</li>
<li><code>attempt</code> (number): Retry attempt counter stored in message fields.</li>
</ul>
<p>If Redis returns nothing, an empty array is returned.</p>
<hr>
<h2 id="typical-usage-2" class="tsd-anchor-link">Typical usage<a href="#typical-usage-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2>
<p>You normally don't call this directly. It is called inside <a href="#consumerloop" class="tsd-kind-method">consumerLoop</a>:</p>
<pre><code class="ts"><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-4">tasks</span><span class="hl-1"> = </span><span class="hl-6">await</span><span class="hl-1"> </span><span class="hl-3">this</span><span class="hl-1">.</span><span class="hl-0">select</span><span class="hl-1">(</span><span class="hl-2">&#39;alerts&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;$&#39;</span><span class="hl-1">);</span><br/><span class="hl-6">if</span><span class="hl-1"> (</span><span class="hl-5">tasks</span><span class="hl-1">.</span><span class="hl-5">length</span><span class="hl-1">) {</span><br/><span class="hl-1">  </span><span class="hl-11">// handle tasks...</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</div></li></ul></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">&gt;</span></h4><p>A promise that resolves to an array of normalized tasks.
Returns an empty array if no tasks are available.</p>
<aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/ihor-bielchenko/power-queues/blob/d8e695c96c32c11bf66176379deee018c4e2b3ff/src/PowerQueues.ts#L1249">PowerQueues.ts:1249</a></li></ul></aside></div></li></ul></section></section></details></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h3>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-private" name="private" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Private</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h3>On This Page</h3></summary><div class="tsd-accordion-details"><details open class="tsd-accordion tsd-page-navigation-section"><summary class="tsd-accordion-summary" data-key="section-Constructors"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Constructors</summary><div><a href="#constructor"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Constructor"><use href="../assets/icons.svg#icon-512"></use></svg><span>constructor</span></a></div></details><details open class="tsd-accordion tsd-page-navigation-section"><summary class="tsd-accordion-summary" data-key="section-Properties"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Properties</summary><div><a href="#approvecount"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>approve<wbr/>Count</span></a><ul><li><ul><li><a href="#what-approve-means-here"><span>What &quot;approve&quot; means here</span></a></li><li><a href="#why-it-matters"><span>Why it matters</span></a></li><li><a href="#tuning-recommendations"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#buildbatchcount"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>build<wbr/>Batch<wbr/>Count</span></a><ul><li><ul><li><a href="#tuning-recommendations-1"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#buildbatchmaxcount"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>build<wbr/>Batch<wbr/>Max<wbr/>Count</span></a><ul><li><ul><li><a href="#how-it-is-calculated-in-your-code"><span>How it is calculated in your code</span></a></li><li><a href="#why-the-name-contains-count"><span>Why the name contains &quot;<wbr/>Count&quot;</span></a></li><li><a href="#tuning-recommendations-2"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#executesync"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>execute<wbr/>Sync</span></a><ul><li><ul><li><a href="#why-this-setting-exists"><span>Why this setting exists</span></a></li><li><a href="#behavior-in-this-implementation"><span>Behavior in this implementation</span></a></li><li><a href="#tuning-recommendations-3"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#group"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>group</span></a><ul><li><ul><li><a href="#what-is-a-consumer-group"><span>What is a consumer group?</span></a></li><li><a href="#how-this-affects-scaling"><span>How this affects scaling</span></a></li><li><ul><li><a href="#horizontal-scaling-multiple-workers"><span>Horizontal scaling (multiple workers)</span></a></li><li><a href="#independent-processing"><span>Independent processing</span></a></li></ul></li><li><a href="#example-scenarios"><span>Example scenarios</span></a></li><li><a href="#best-practices"><span>Best practices</span></a></li></ul></li></ul><a href="#host"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>host</span></a><a href="#idemdonetimeout"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>idem<wbr/>Done<wbr/>Timeout</span></a><ul><li><ul><li><a href="#where-it-is-used"><span>Where it is used</span></a></li><li><a href="#why-it-matters-1"><span>Why it matters</span></a></li><li><a href="#tuning-recommendations-4"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#idemlocktimeout"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>idem<wbr/>Lock<wbr/>Timeout</span></a><ul><li><ul><li><a href="#where-it-is-used-1"><span>Where it is used</span></a></li><li><a href="#why-it-matters-2"><span>Why it matters</span></a></li><li><a href="#tuning-recommendations-5"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#logstatus"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>log<wbr/>Status</span></a><ul><li><ul><li><a href="#why-it-matters-3"><span>Why it matters</span></a></li><li><a href="#tuning-recommendations-6"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#logstatustimeout"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>log<wbr/>Status<wbr/>Timeout</span></a><ul><li><ul><li><a href="#why-it-matters-4"><span>Why it matters</span></a></li><li><a href="#where-it-is-used-2"><span>Where it is used</span></a></li><li><a href="#tuning-recommendations-7"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#removeonexecuted"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>remove<wbr/>On<wbr/>Executed</span></a><ul><li><ul><li><a href="#how-it-is-used"><span>How it is used</span></a></li><li><a href="#tuning-recommendations-8"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#retrycount"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>retry<wbr/>Count</span></a><ul><li><ul><li><a href="#what-happens-on-failure"><span>What happens on failure</span></a></li><li><a href="#tuning-recommendations-9"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#selectcount"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>select<wbr/>Count</span></a><ul><li><ul><li><a href="#why-it-matters-5"><span>Why it matters</span></a></li><li><a href="#tuning-recommendations-10"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#selectstuckcount"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>select<wbr/>Stuck<wbr/>Count</span></a><ul><li><ul><li><a href="#how-it-is-used-1"><span>How it is used</span></a></li><li><a href="#why-it-matters-6"><span>Why it matters</span></a></li><li><a href="#tuning-recommendations-11"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#selectstuckmaxtimeout"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>select<wbr/>Stuck<wbr/>Max<wbr/>Timeout</span></a><ul><li><ul><li><a href="#how-it-is-used-2"><span>How it is used</span></a></li><li><a href="#why-it-matters-7"><span>Why it matters</span></a></li><li><a href="#tuning-recommendations-12"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#selectstucktimeout"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>select<wbr/>Stuck<wbr/>Timeout</span></a><ul><li><ul><li><a href="#how-it-is-used-3"><span>How it is used</span></a></li><li><a href="#why-it-matters-8"><span>Why it matters</span></a></li><li><a href="#tuning-recommendations-13"><span>Tuning recommendations</span></a></li></ul></li></ul><a href="#selecttimeout"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Property"><use href="../assets/icons.svg#icon-1024"></use></svg><span>select<wbr/>Timeout</span></a><ul><li><a href="#why-it-matters-9"><span>Why it matters</span></a></li><li><a href="#behavior-in-this-implementation-1"><span>Behavior in this implementation</span></a></li><li><a href="#tuning-recommendations-14"><span>Tuning recommendations</span></a></li></ul></div></details><details open class="tsd-accordion tsd-page-navigation-section"><summary class="tsd-accordion-summary" data-key="section-Methods"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Methods</summary><div><a href="#addtasks"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>add<wbr/>Tasks</span></a><ul><li><ul><li><a href="#what-is-written-into-redis"><span>What is written into <wbr/>Redis?</span></a></li><li><a href="#parameters"><span>Parameters</span></a></li><li><a href="#how-batching-works"><span>How batching works</span></a></li><li><a href="#return-value"><span>Return value</span></a></li><li><a href="#errors-and-validation"><span>Errors and validation</span></a></li><li><a href="#example"><span>Example</span></a></li></ul></li></ul><a href="#beforeexecute"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>before<wbr/>Execute</span></a><ul><li><ul><li><a href="#parameters-1"><span>Parameters</span></a></li><li><a href="#return-value-1"><span>Return value</span></a></li><li><a href="#important-notes-for-overrides"><span>Important notes for overrides</span></a></li><li><a href="#example-override-filter-invalid-payloads"><span>Example override: filter invalid payloads</span></a></li><li><a href="#example-override-add-defaults"><span>Example override: add defaults</span></a></li></ul></li></ul><a href="#consumerloop"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>consumer<wbr/>Loop</span></a><ul><li><ul><li><a href="#why-a-loop-is-needed"><span>Why a loop is needed</span></a></li><li><a href="#parameters-2"><span>Parameters</span></a></li><li><a href="#detailed-behavior"><span>Detailed behavior</span></a></li><li><ul><li><a href="#stop-condition"><span>Stop condition</span></a></li><li><a href="#reading-tasks-select"><span>Reading tasks: select</span></a></li><li><a href="#when-no-tasks-were-read"><span>When no tasks were read</span></a></li><li><a href="#execution-and-acknowledgment"><span>Execution and acknowledgment</span></a></li><li><a href="#error-handling-batch-level"><span>Error handling (batch-<wbr/>level)</span></a></li></ul></li><li><a href="#notes-best-practices"><span>Notes &amp; best practices</span></a></li></ul></li></ul><a href="#creategroup"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>create<wbr/>Group</span></a><ul><li><ul><li><a href="#what-it-creates"><span>What it creates</span></a></li><li><a href="#parameters-3"><span>Parameters</span></a></li><li><a href="#error-handling-behavior"><span>Error handling behavior</span></a></li><li><a href="#typical-usage"><span>Typical usage</span></a></li></ul></li></ul><a href="#loadscripts"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>load<wbr/>Scripts</span></a><ul><li><ul><li><a href="#why-do-we-need-this"><span>Why do we need this?</span></a></li><li><a href="#parameters-4"><span>Parameters</span></a></li><li><a href="#when-should-you-call-it"><span>When should you call it?</span></a></li><li><a href="#what-this-method-does-internally"><span>What this method does internally</span></a></li></ul></li></ul><a href="#onbatcherror"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Batch<wbr/>Error</span></a><ul><li><ul><li><a href="#important-retrydlq-logic-is-not-done-here"><span>Important: retry/<wbr/>DLQ logic is <wbr/>NOT done here</span></a></li><li><a href="#parameters-5"><span>Parameters</span></a></li><li><a href="#return-value-2"><span>Return value</span></a></li><li><a href="#common-use-cases"><span>Common use cases</span></a></li><li><a href="#important-notes-for-overrides-1"><span>Important notes for overrides</span></a></li><li><a href="#example-override-log-batch-summary"><span>Example override: log batch summary</span></a></li></ul></li></ul><a href="#onbatchready"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Batch<wbr/>Ready</span></a><ul><li><ul><li><a href="#what-is-in-the-batch"><span>What is in the batch?</span></a></li><li><a href="#why-this-hook-exists"><span>Why this hook exists</span></a></li><li><a href="#parameters-6"><span>Parameters</span></a></li><li><a href="#return-value-3"><span>Return value</span></a></li><li><a href="#important-notes-for-overrides-2"><span>Important notes for overrides</span></a></li><li><a href="#example-override-lightweight-metrics"><span>Example override: lightweight metrics</span></a></li></ul></li></ul><a href="#onerror"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Error</span></a><ul><li><ul><li><a href="#important-this-hook-does-not-mean-the-message-was-acked"><span>Important: this hook does <wbr/>NOT mean &quot;the message was <wbr/>AC<wbr/>Ked&quot;</span></a></li><li><a href="#parameters-7"><span>Parameters</span></a></li><li><a href="#return-value-4"><span>Return value</span></a></li><li><a href="#common-use-cases-1"><span>Common use cases</span></a></li><li><a href="#important-notes-for-overrides-3"><span>Important notes for overrides</span></a></li><li><a href="#example-override-sentry-structured-logging"><span>Example override: <wbr/>Sentry + structured logging</span></a></li></ul></li></ul><a href="#onexecute"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Execute</span></a><ul><li><ul><li><a href="#where-it-sits-in-the-pipeline"><span>Where it sits in the pipeline</span></a></li><li><a href="#parameters-8"><span>Parameters</span></a></li><li><a href="#return-value-5"><span>Return value</span></a></li><li><a href="#how-to-signal-failure"><span>How to signal failure</span></a></li><li><a href="#important-notes-for-overrides-practical-advice"><span>Important notes for overrides (practical advice)</span></a></li><li><a href="#example-override-send-telegram-message"><span>Example override: send <wbr/>Telegram message</span></a></li></ul></li></ul><a href="#onretry"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Retry</span></a><ul><li><ul><li><a href="#when-exactly-it-happens-in-the-flow"><span>When exactly it happens in the flow</span></a></li><li><a href="#parameters-9"><span>Parameters</span></a></li><li><a href="#return-value-6"><span>Return value</span></a></li><li><a href="#common-use-cases-2"><span>Common use cases</span></a></li><li><a href="#important-notes-for-overrides-4"><span>Important notes for overrides</span></a></li><li><a href="#example-override-log-retry-scheduling"><span>Example override: log retry scheduling</span></a></li></ul></li></ul><a href="#onsuccess"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>on<wbr/>Success</span></a><ul><li><ul><li><a href="#parameters-10"><span>Parameters</span></a></li><li><a href="#return-value-7"><span>Return value</span></a></li><li><a href="#common-use-cases-3"><span>Common use cases</span></a></li><li><a href="#important-notes-for-overrides-5"><span>Important notes for overrides</span></a></li><li><a href="#example-override-per-task-logging"><span>Example override: per-<wbr/>task logging</span></a></li></ul></li></ul><a href="#runqueue"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>run<wbr/>Queue</span></a><ul><li><ul><li><a href="#what-is-a-queue-here"><span>What is a &quot;queue&quot; here?</span></a></li><li><a href="#what-is-a-consumer-group-1"><span>What is a &quot;consumer group&quot;?</span></a></li><li><a href="#parameters-11"><span>Parameters</span></a></li><li><a href="#how-it-works-internally"><span>How it works internally</span></a></li><li><ul><li><a href="#1-remove-listener-limits-for-abortsignal"><span>1) <wbr/>Remove listener limits for <wbr/>Abort<wbr/>Signal</span></a></li><li><a href="#2-create-the-consumer-group-if-missing"><span>2) <wbr/>Create the consumer group (if missing)</span></a></li><li><a href="#3-start-the-consumer-loop"><span>3) <wbr/>Start the consumer loop</span></a></li></ul></li><li><a href="#typical-usage-1"><span>Typical usage</span></a></li><li><a href="#notes-best-practices-1"><span>Notes &amp; best practices</span></a></li></ul></li></ul><a href="#select"><svg class="tsd-kind-icon" viewBox="0 0 24 24" aria-label="Method"><use href="../assets/icons.svg#icon-2048"></use></svg><span>select</span></a><ul><li><a href="#why-stuck-first"><span>Why &quot;stuck first&quot;?</span></a></li><li><a href="#parameters-12"><span>Parameters</span></a></li><li><a href="#return-value-format"><span>Return value format</span></a></li><li><a href="#typical-usage-2"><span>Typical usage</span></a></li></ul></div></details></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="../modules.html">power-queues API Docs - v2.1.10</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>
